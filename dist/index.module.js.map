{"version":3,"file":"index.module.js","sources":["../src/MessageBridgeTypes.ts","../src/MessageBridgeHelper.ts","../src/MessageBridgeServiceBase.ts","../src/services/SignalRMessageBridgeService.ts","../src/services/WebsocketMessageBridgeService.ts","../src/services/ClientSideMessageBridgeService.ts","../src/services/InMemoryClientSideServer.ts"],"sourcesContent":["// Typescript util\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type OmitAndOptional<\n  T,\n  TOmit extends keyof T,\n  TOpt extends keyof Omit<T, TOmit>,\n> = Pick<Partial<Omit<T, TOmit>>, TOpt> & Omit<Omit<T, TOmit>, TOpt>\n\n// bridge\nexport type BridgeOptions = {\n  // Add listeners:\n  onMessage?: (msg: Message) => void\n  onSend?: (msg: Message) => void\n  onError?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onSuccess?: (msg: RequestResponse) => void\n  onClose?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onConnect?: () => void\n  // Can be used to send a cancel request to the server\n  onCancel?: (msg: Message) => void\n  // Interception:\n  // - can be used to generalize behavior (Happens as early as possible in the process)\n  // Happens just after user options is applied. Before stored in track map and before any other actions.\n  interceptSendMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after message-string parsing, but before stored in history, onMessage and all other actions\n  // To get request for the message use: getTrackedRequestMessage(trackId: string): Message | undefined\n  interceptReceivedMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after the options for createMessage is applied)\n  interceptCreatedMessageOptions?: (msg: CreatedMessage) => CreatedMessage // (default: undefined)\n  interceptCreatedEventMessageOptions?: (msg: CreatedEvent) => CreatedEvent // (default: undefined)\n  // Handle errors and timeouts:\n  avoidThrowOnNonTrackedError?: boolean // (default: undefined)\n  throwOnTrackedError?: boolean // (default: undefined)\n  timeout?: number // (default: undefined)\n  // Cancel\n  // resolve on cancel (Let the process that did the request handle the cancel)\n  resolveCancelledNonTrackedRequest?: boolean // (default: undefined)\n  sendCancelledRequest?: boolean // (default: undefined)\n  callOnErrorWhenRequestIsCancelled?: boolean // (default: undefined)\n  callOnSuccessWhenRequestIsCancelled?: boolean // (default: undefined)\n  // if true, the response can still have a value, else it will be undefined\n  allowResponseValueWhenCancelled?: boolean // (default: undefined)\n  // Debugging options:\n  timeoutFromBridgeOptionsMessage?: (ms: number) => string // (has default implementation)\n  timeoutFromRequestOptionsMessage?: (ms: number) => string // (has default implementation)\n  keepHistoryForReceivedMessages?: boolean // (default: false)\n  keepHistoryForSendingMessages?: boolean // (default: false)\n  logger?: (...data: any[]) => void // set custom logger (default: console?.log)\n  logParseIncomingMessageError?: boolean // (default: true)\n  logParseIncomingMessageErrorFormat?: (err: unknown) => any[] // (has default implementation)\n  logMessageReceived?: boolean // log all messages received\n  logMessageReceivedFormat?: (msg: Message) => any[] // (has default implementation)\n  logSendingMessage?: boolean // log all messages sent\n  logSendingMessageFormat?: (msg: Message) => any[] // (has default implementation)\n  logMessageReceivedFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n  logSendingMessageFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n}\n// enums (These are runtime enums)\nexport enum MessageType {\n  Command = \"Command\",\n  CommandResponse = \"CommandResponse\",\n  Query = \"Query\",\n  QueryResponse = \"QueryResponse\",\n  Event = \"Event\",\n  Error = \"Error\",\n}\n\nexport enum MessageDirection {\n  ToClient = \"ToClient\",\n  ToServer = \"ToServer\",\n}\n\n// types (Not runtime)\nexport type Message<TPayload = any, TSchema = any> = {\n  module?: string\n  name: string\n  type: MessageType\n  isError: boolean\n  cancelled?: boolean\n  timedOut?: boolean\n  trackId: string\n  created: string\n  payload: TPayload\n  schema?: TSchema\n  direction: MessageDirection\n}\n\n// Request\nexport type RequestResponse<TRequest = any, TResponse = any, TError = any> = {\n  response: TResponse\n  request: TRequest\n  responseMessage: Message<TResponse>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  isError?: boolean\n  error?: TError\n  errorMessage?: Message<TError>\n  cancelled?: boolean\n  timedOut?: boolean\n}\n\nexport type RequestOptions<TRequest, TResponse, TError = any> = {\n  name: string\n  payload: TRequest\n  onSuccess?: TrackedOnSuccess<TRequest, TResponse>\n  onError?: TrackedOnError<TRequest, TResponse, TError>\n  module?: string\n  timeout?: number\n  resolveCancelledForNonTracked?: boolean\n  sendCancelled?: boolean\n  callOnErrorWhenRequestIsCancelled?: boolean\n  callOnSuccessWhenRequestIsCancelled?: boolean\n  allowResponseValueWhenCancelled?: boolean\n}\n\nexport type SendMessageOptions<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n\nexport type CreatedMessage<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  trackId: string\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  send: () => Promise<TResponse>\n  sendTracked: () => Promise<RequestResponse<TRequest, TResponse, TError>>\n  cancel: () => void\n}\n\nexport type CreatedEvent<TPayload = any> = {\n  trackId: string\n  requestMessage: Message<TPayload>\n  requestOptions: EventOptions<TPayload>\n  send: () => void\n  cancel: () => void\n}\n\nexport type EventOptions<TPayload = any> = {\n  name: string\n  payload: TPayload\n  module?: string\n  sendCancelled?: boolean\n}\n\nexport type TrackedOnSuccess<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => void\n\nexport type TrackedOnError<TRequest = any, TResponse = any, TError = any> = (\n  opt: RequestResponse<TRequest, TResponse, TError>,\n) => void\n\nexport type SubscribeEvent<TResponse> = (\n  payload: TResponse,\n  eventMessage: Message<TResponse>,\n) => void\n\n// Error\nexport type RequestMaybeNoError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type OnTimeoutHandler<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => void\n\n// Internal Tracked\n// used by tracking (No return value '=> void', it uses promise 'resolve')\nexport type InternalTrackedOnSuccess<TResponse> = (\n  responseMessage: Message<TResponse>,\n) => void\n\nexport type InternalTrackedOnError<TError> = (\n  responseMessage: Message<TError> | undefined,\n) => void\n\nexport type InternalTrackedRequest<TRequest, TResponse, TError = any> = {\n  successTrack: InternalTrackedOnSuccess<TResponse>\n  errorTrack: InternalTrackedOnError<TError>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  OmitAndOptional,\n} from \"./MessageBridgeTypes\"\nimport { v4 } from \"uuid\"\n\nexport function createMessageFromDto<TPayload = any, TSchema = any>(\n  msg: Message<TPayload, TSchema>,\n  direction = MessageDirection.ToClient,\n): Message<TPayload, TSchema> {\n  msg.isError = msg.type === MessageType.Error\n  msg.direction ??= direction\n  return msg\n}\n\nexport function MapResponseType(type: MessageType) {\n  switch (type) {\n    case MessageType.Command:\n      return MessageType.CommandResponse\n    case MessageType.Query:\n      return MessageType.QueryResponse\n    default:\n      return type\n  }\n}\n\nexport function createMessage<TPayload = any | undefined, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TPayload, TSchema>,\n    \"created\" | \"isError\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TPayload, TSchema> {\n  return {\n    name: opt.name,\n    payload: opt.payload,\n    type: opt.type,\n    // optionals\n    direction: opt.direction ?? MessageDirection.ToClient,\n    trackId: opt.trackId ?? v4(),\n    module: opt.module,\n    schema: opt.schema,\n    // alway created\n    created: new Date().toISOString(),\n    isError: opt.type === MessageType.Error,\n  }\n}\n\nexport function createCommandMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TRequest, TSchema> {\n  return createMessage({\n    ...opt,\n    type: MessageType.Command,\n  })\n}\n\nexport function createQueryMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Query,\n  })\n}\n\nexport function createEventMessage<TPayload = any>(\n  opt: OmitAndOptional<\n    Message<TPayload>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage<TPayload>({\n    ...opt,\n    type: MessageType.Event,\n  })\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  RequestResponse,\n  SubscribeEvent,\n  InternalTrackedRequest,\n  OmitAndOptional,\n  OnTimeoutHandler,\n  RequestOptions,\n  BridgeOptions,\n  RequestMaybeNoError,\n  SendMessageOptions,\n  CreatedMessage,\n  CreatedEvent,\n  EventOptions,\n} from \"./MessageBridgeTypes\"\n\nimport {\n  createCommandMessage,\n  createEventMessage,\n  createMessageFromDto,\n  createQueryMessage,\n} from \"./MessageBridgeHelper\"\n\nexport abstract class MessageBridgeServiceBase {\n  connected = false\n  trackedRequestMap: {\n    [trackId: string]: InternalTrackedRequest<any, any>\n  } = {}\n\n  subscribedEventListMap: {\n    [eventName: string]: SubscribeEvent<any>[]\n  } = {}\n\n  history: Message[] = []\n  bridgeErrors: unknown[] /*Error*/ = []\n\n  options: BridgeOptions = {\n    timeout: undefined,\n    allowResponseValueWhenCancelled: false,\n    keepHistoryForReceivedMessages: false,\n    keepHistoryForSendingMessages: false,\n    logger: console?.log ?? (() => {}),\n    logParseIncomingMessageError: true,\n    timeoutFromBridgeOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (BridgeOptions.timeout)`,\n    timeoutFromRequestOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (RequestOptions.timeout)`,\n    logParseIncomingMessageErrorFormat: (err: unknown) => [\n      \"Bridge-Error (parse messageReceived):\",\n      err,\n    ],\n    logMessageReceived: false,\n    logMessageReceivedFormat: (msg: Message) => [\"Bridge (messageReceived):\", msg],\n    logSendingMessage: false,\n    logSendingMessageFormat: (msg: Message) => [\"Bridge (sendingMessage):\", msg],\n  }\n\n  constructor(public wsUri: string) {}\n\n  abstract connect(options?: unknown): Promise<void>\n  abstract close(): void\n  abstract sendNetworkMessage(msg: Message): void\n\n  setOptions(opt: BridgeOptions) {\n    this.options = { ...this.options, ...opt }\n  }\n\n  getTrackedRequestMessage(trackId: string): Message | undefined {\n    return this.trackedRequestMap[trackId]?.requestMessage\n  }\n\n  // This will not cancel the request itself (on the server),\n  // but set a cancel flag on the trackMap (so the response will be ignored)\n  cancelRequest(trackId: string): void {\n    if (this.trackedRequestMap[trackId]) {\n      this.trackedRequestMap[trackId].requestMessage.cancelled = true\n    }\n  }\n\n  // the following methods can overwritten with class inheritance\n  // but should override version should call super.methodName()\n  protected onConnect() {\n    this.connected = true\n    this.options.onConnect?.()\n  }\n  protected onError(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.options.onError?.(err, eventOrData)\n  }\n  protected onClose(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.connected = false\n    this.options.onClose?.(err, eventOrData)\n  }\n\n  // base methods (should mostly not be overwritten)\n  protected setOptionalRequestTimeout<TRequest = any, TSchema = any>({\n    requestMessage,\n    timeout,\n    onTimeout,\n  }: {\n    requestMessage: Message<TRequest, TSchema>\n    timeout: number | undefined\n    onTimeout: OnTimeoutHandler<string, TRequest>\n  }) {\n    let reason: string\n    let timeoutMs: number | undefined\n\n    if (timeout !== undefined) {\n      reason =\n        this.options.timeoutFromRequestOptionsMessage?.(timeout) ??\n        `timeout after ${timeout}`\n      timeoutMs = timeout\n    } else if (this.options.timeout !== undefined) {\n      reason =\n        this.options.timeoutFromBridgeOptionsMessage?.(this.options.timeout) ??\n        `timeout after ${this.options.timeout}`\n      timeoutMs = this.options.timeout\n    }\n\n    if (timeoutMs === undefined) {\n      return\n    }\n    return setTimeout(() => {\n      requestMessage.timedOut = true\n      const opt: RequestMaybeNoError<string, TRequest> = {\n        reason,\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n      }\n      onTimeout(opt)\n    }, timeoutMs)\n  }\n\n  sendMessageTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        // check cancel\n        const cancelPromiseValue = {\n          request: opt.requestMessage.payload,\n          requestMessage: opt.requestMessage,\n          cancelled: true,\n          //responseMessage: undefined\n          //response: undefined,\n        } as RequestResponse<TRequest, TResponse, TError>\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<RequestResponse<TRequest, TResponse, TError>>(\n      (resolve, reject) => {\n        this.sendMessagePromiseHandler({\n          ...opt,\n          handleSuccess: (cancelled, response) => {\n            resolve(response)\n          },\n          handleError: (cancelled, response) => {\n            if (this.options.throwOnTrackedError) {\n              reject(response)\n            } else {\n              resolve(response)\n            }\n          },\n        })\n      },\n    ).finally(() => {\n      delete this.trackedRequestMap[opt.requestMessage.trackId]\n    })\n  }\n\n  /**\n   * Only resolve the promise with the TResponse (not the tracked/full response)\n   * onSuccess contains the response in the first argument (and the the tracked/full response in the second argument)\n   */\n  sendMessage<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    // check cancel\n    const cancelPromiseValue = undefined as TResponse\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<TResponse>((resolve, reject) => {\n      this.sendMessagePromiseHandler({\n        ...opt,\n        handleSuccess: (cancelled, response) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n            return\n          }\n          resolve(response.response)\n        },\n        handleError: (cancelled, response, error) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n          }\n          if (this.options.avoidThrowOnNonTrackedError) {\n            //@ts-ignore (The response is not the correct type, but we ignore it)\n            resolve(error?.payload)\n          } else {\n            reject(response)\n          }\n        },\n      })\n    })\n  }\n\n  protected sendMessagePromiseHandler<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >({\n    handleError,\n    handleSuccess,\n    requestMessage,\n    requestOptions,\n  }: SendMessageOptions<TRequest, TResponse, TError, TSchema> & {\n    handleError: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n      error?: RequestMaybeNoError<any, TRequest>,\n    ) => void\n    handleSuccess: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n    ) => void\n  }) {\n    requestMessage.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      requestMessage = this.options.interceptSendMessage(requestMessage)\n    }\n\n    // handle error and timeout\n    const handleErrorMessage = (\n      cancelled: boolean,\n      errOpt: RequestMaybeNoError<any, TRequest>,\n    ) => {\n      if (optionalTimeId) {\n        clearTimeout(optionalTimeId)\n      }\n\n      // resolve with error\n      const resolveWithError: RequestResponse<TRequest, TResponse, TError> = {\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        response: undefined,\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n        isError: true,\n        error: errOpt.reason,\n        errorMessage: errOpt.responseMessage,\n        cancelled:\n          requestMessage.cancelled ||\n          errOpt.requestMessage?.cancelled ||\n          errOpt.responseMessage?.cancelled,\n        timedOut:\n          requestMessage.timedOut ||\n          errOpt.requestMessage?.timedOut ||\n          errOpt.responseMessage?.timedOut,\n      }\n      if (\n        !cancelled ||\n        !this.options.callOnErrorWhenRequestIsCancelled ||\n        !requestOptions.callOnErrorWhenRequestIsCancelled\n      ) {\n        this.onError(resolveWithError)\n        requestOptions.onError?.(resolveWithError)\n      }\n      handleError(cancelled, resolveWithError, errOpt)\n    }\n    // set timeout if needed\n    const optionalTimeId = this.setOptionalRequestTimeout({\n      requestMessage,\n      timeout: requestOptions.timeout,\n      onTimeout: (timeoutErrorMessage) => {\n        const cancelled = this.handleCancelOptions(requestOptions, requestMessage)\n        handleErrorMessage(cancelled, timeoutErrorMessage)\n      },\n    })\n    // add to subscribedTrackIdMap\n    const track: InternalTrackedRequest<TRequest, TResponse, TError> = {\n      successTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestResponse<TRequest, TResponse, TError> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          response: response as TResponse,\n          responseMessage,\n          requestOptions,\n          request: requestMessage.payload,\n          requestMessage,\n          isError: false,\n          cancelled: requestMessage.cancelled || responseMessage.cancelled,\n          timedOut: requestMessage.timedOut || responseMessage.timedOut,\n        }\n        if (optionalTimeId) {\n          clearTimeout(optionalTimeId)\n        }\n\n        if (\n          !cancelled ||\n          !!this.options.callOnSuccessWhenRequestIsCancelled ||\n          !!requestOptions.callOnSuccessWhenRequestIsCancelled\n        ) {\n          this.options.onSuccess?.(opt)\n          requestOptions.onSuccess?.(opt)\n        }\n        handleSuccess(cancelled, opt)\n      },\n      errorTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestMaybeNoError<TError, TRequest> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          reason: response as TError,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n        }\n        handleErrorMessage(cancelled, opt)\n      },\n      requestMessage: requestMessage,\n      requestOptions,\n    }\n    this.trackedRequestMap[requestMessage.trackId] = track\n\n    // send message\n    this.internalSendMessage(requestMessage)\n  }\n\n  private handleCancelOptions<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    let resolveCancel = false\n    if (requestOptions.resolveCancelledForNonTracked !== undefined) {\n      resolveCancel = requestOptions.resolveCancelledForNonTracked\n    } else if (this.options.resolveCancelledNonTrackedRequest) {\n      resolveCancel = true\n    }\n    let cancelled = false\n    if (responseMessage?.cancelled || requestMessage.cancelled) {\n      cancelled = true\n    }\n    if (resolveCancel && cancelled) {\n      cancelled = false\n    }\n    return cancelled\n  }\n\n  private handleCancelResponse<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    const cancelled = this.handleCancelOptions(\n      requestOptions,\n      requestMessage,\n      responseMessage,\n    )\n    let response = responseMessage?.payload\n    if (cancelled) {\n      if (requestOptions.allowResponseValueWhenCancelled !== undefined) {\n        if (requestOptions.allowResponseValueWhenCancelled !== true) {\n          response = undefined as TResponse\n        }\n      } else if (this.options.allowResponseValueWhenCancelled !== true) {\n        response = undefined as TResponse\n      }\n    }\n    return { response, cancelled }\n  }\n\n  subscribeEvent<TResponse = any>({\n    name,\n    onEvent,\n  }: {\n    name: string | string[]\n    onEvent: SubscribeEvent<TResponse>\n  }): () => void {\n    if (Array.isArray(name)) {\n      const unsubs = name.map((_name) => this.subscribeEvent({ name: _name, onEvent }))\n      return () => unsubs.forEach((unsub) => unsub())\n    }\n    if (!this.subscribedEventListMap[name]) this.subscribedEventListMap[name] = []\n    this.subscribedEventListMap[name].push(onEvent)\n    return () => {\n      const index = this.subscribedEventListMap[name].findIndex((x) => x === onEvent)\n      this.subscribedEventListMap[name].splice(index, 1)\n    }\n  }\n\n  private createTrackedMessage<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    sendOptions: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const trackId = sendOptions.requestMessage.trackId\n    let createdMessage: CreatedMessage = {\n      trackId: trackId,\n      requestMessage: sendOptions.requestMessage,\n      requestOptions: sendOptions.requestOptions,\n      send: () => this.sendMessage(sendOptions),\n      sendTracked: () => this.sendMessageTracked(sendOptions),\n      cancel: () => {\n        // before run\n        if (sendOptions?.requestMessage) {\n          sendOptions.requestMessage.cancelled = true\n        }\n        // running\n        this.cancelRequest(trackId)\n      },\n    }\n    if (this.options.interceptCreatedMessageOptions) {\n      createdMessage = this.options.interceptCreatedMessageOptions(createdMessage)\n    }\n    return createdMessage\n  }\n\n  createCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createCommandMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  createQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createQueryMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  sendCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendCommandTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  sendQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendQueryTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  createEvent<TPayload = any>(\n    eventOptions: EventOptions<TPayload>,\n  ): CreatedEvent<TPayload> {\n    let eventMessage = createEventMessage<TPayload>(eventOptions)\n    eventMessage.direction = MessageDirection.ToServer\n    let createdEvent: CreatedEvent = {\n      trackId: eventMessage.trackId,\n      requestMessage: eventMessage,\n      requestOptions: eventOptions,\n      cancel: () => {\n        // before run\n        if (eventMessage) {\n          eventMessage.cancelled = true\n        }\n      },\n      send: () => {\n        if (eventMessage.cancelled) {\n          if (eventOptions.sendCancelled !== undefined) {\n            if (!eventOptions.sendCancelled) {\n              return\n            }\n          } else if (!this.options.sendCancelledRequest) {\n            return\n          }\n        }\n        if (this.options.interceptSendMessage) {\n          eventMessage = this.options.interceptSendMessage(eventMessage)\n        }\n        this.internalSendMessage(eventMessage)\n      },\n    }\n    if (this.options.interceptCreatedEventMessageOptions) {\n      createdEvent = this.options.interceptCreatedEventMessageOptions(createdEvent)\n    }\n\n    return createdEvent\n  }\n\n  sendEvent<TPayload = any>(\n    eventOptions: OmitAndOptional<\n      Message<TPayload>,\n      \"trackId\" | \"created\" | \"isError\" | \"type\",\n      \"direction\"\n    >,\n  ) {\n    return this.createEvent<TPayload>(eventOptions).send()\n  }\n\n  protected onMessage(messageString: string | Message) {\n    //console.log(\"onMessage\", messageString)\n    let messageDto: Message\n    try {\n      messageDto =\n        typeof messageString === \"string\"\n          ? (JSON.parse(messageString) as Message)\n          : messageString\n    } catch (e) {\n      this.onError(e as Error)\n      //console.log(\"Incorrect message received: \" + messageString)\n      return\n    }\n    try {\n      let msg = createMessageFromDto(messageDto)\n      if (this.options.interceptReceivedMessage) {\n        msg = this.options.interceptReceivedMessage(msg)\n      }\n      this.handleIncomingMessage(msg)\n    } catch (e) {\n      this.onError(e as Error)\n      if (this.options.logger && this.options.logParseIncomingMessageError) {\n        const logData = this.options.logParseIncomingMessageErrorFormat?.(messageDto) ?? [\n          e,\n        ]\n        this.options.logger(logData)\n      }\n    }\n  }\n\n  protected internalSendMessage(msg: Message) {\n    if (this.options.keepHistoryForSendingMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logSendingMessage) {\n      let log = true\n      if (this.options.logSendingMessageFilter) {\n        log = !!msg.name.match(this.options.logSendingMessageFilter)\n      }\n      if (log) {\n        const logData = this.options.logSendingMessageFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onSend?.(msg)\n    this.sendNetworkMessage(msg)\n  }\n\n  protected handleIncomingMessage(msg: Message) {\n    //console.log(\"handleIncomingMessage\", msg)\n    if (this.options.keepHistoryForReceivedMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logMessageReceived) {\n      let log = true\n      if (this.options.logMessageReceivedFilter) {\n        log = !!msg.name.match(this.options.logMessageReceivedFilter)\n      }\n      if (log) {\n        const logData = this.options.logMessageReceivedFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onMessage?.(msg)\n\n    let errorHandled = msg.type !== MessageType.Error\n\n    if (msg.type === MessageType.Event) {\n      this.receiveEventMessage(msg)\n      return\n    }\n    const trackMsg = this.trackedRequestMap[msg.trackId]\n    if (trackMsg) {\n      if (msg.type === MessageType.Error) {\n        trackMsg.errorTrack(msg)\n        errorHandled = true\n      } else {\n        trackMsg.successTrack(msg)\n      }\n      delete this.trackedRequestMap[msg.trackId]\n    }\n\n    if (!errorHandled) {\n      this.onError?.(msg)\n    }\n  }\n\n  protected receiveEventMessage(eventMsg: Message) {\n    if (this.subscribedEventListMap[eventMsg.name]) {\n      this.subscribedEventListMap[eventMsg.name].forEach((callback) =>\n        callback(eventMsg.payload, eventMsg),\n      )\n    }\n  }\n}\n","import { HubConnectionBuilder } from \"@microsoft/signalr\"\nimport { IHttpConnectionOptions } from \"@microsoft/signalr/src/IHttpConnectionOptions\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class SignalRMessageBridgeService extends MessageBridgeServiceBase {\n  connection?: signalR.HubConnection\n  connect(options: IHttpConnectionOptions = {}): Promise<void> {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.wsUri, options)\n      .withAutomaticReconnect()\n      .build()\n    if (!this.connection) {\n      throw new Error(\"Failed to create SignalR connection\")\n    }\n    this.connection.on(\"ReceiveMessage\", (messageString: string | Message) => {\n      this.onMessage(messageString)\n    })\n    this.connection.onclose((error) => {\n      this.onClose(error)\n    })\n    return this.connection\n      .start()\n      .then(() => {\n        this.onConnect()\n      })\n      .catch((err: Error) => {\n        this.onError(err)\n      })\n  }\n\n  close() {\n    this.connection?.stop()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.connection?.invoke(\"SendMessage\", msgJson).catch((err) => {\n      this.onError(err as Error)\n      return console.error(err.toString())\n    })\n  }\n}\n","import { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class WebsocketMessageBridgeService extends MessageBridgeServiceBase {\n  socket?: WebSocket\n  connectedCallback?: () => void\n\n  connect() {\n    this.socket = new WebSocket(this.wsUri)\n    this.socket.addEventListener(\"message\", (event) => {\n      const messageString: string | Message = event.data\n      this.onMessage(messageString)\n    })\n    this.socket.addEventListener(\"close\", (event) => {\n      this.onClose(event.reason, event)\n    })\n    this.socket.addEventListener(\"error\", (event) => {\n      this.onError(event, event)\n    })\n\n    return new Promise<void>((resolve, reject) => {\n      // Connection opened\n      this.socket?.addEventListener(\"open\", (event) => {\n        this.onConnect()\n        resolve()\n      })\n    })\n  }\n  close(): void {\n    this.socket?.close()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.socket?.send(msgJson)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\n\nexport type MessageBridgeClientServer = {\n  onMessage: (msg: Message) => void\n  connect: (sendMessage: (msg: Message) => void) => void\n}\n\nexport class ClientSideMessageBridgeService extends MessageBridgeServiceBase {\n  server?: MessageBridgeClientServer\n  setServer(server: MessageBridgeClientServer) {\n    this.server = server\n  }\n  connect() {\n    if (!this.server) {\n      throw new Error(\"No server set\")\n    }\n    this.server?.connect((msg) => {\n      // ensure that no object reference is passed to the client\n      const msgDetachRef = JSON.parse(JSON.stringify(msg))\n      this.onMessage(msgDetachRef)\n      this.onConnect()\n    })\n    return Promise.resolve()\n  }\n  close() {\n    this.onClose()\n  }\n  sendNetworkMessage(msg: Message) {\n    // ensure that no object reference is passed to the server\n    const msgDetachRef = JSON.parse(JSON.stringify(msg))\n    setTimeout(() => {\n      this.server?.onMessage(msgDetachRef)\n    }, 10)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\nimport { MessageBridgeClientServer } from \"./ClientSideMessageBridgeService\"\n\nexport type RequestErrorResponse = {\n  message: string\n  request?: Message | string\n  stack?: string\n  error?: unknown\n}\n\nexport type RequestHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any, cancelled?: boolean, timedOut?: boolean) => void\n  response: (response: TResponse) => void\n  sendResponseMessage: (responseMessage: Message<TRequest, TResponse>) => void\n  createResponseMessage(response: TResponse): Message<TRequest, TResponse>\n}) => void\n\nexport type RequestEventHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n}) => void\n\nexport class InMemoryClientSideServer<TStore> implements MessageBridgeClientServer {\n  store = {} as TStore\n  commands = {} as { [name: string]: RequestHandler }\n  queries = {} as { [name: string]: RequestHandler }\n  eventListeners = {} as { [name: string]: RequestEventHandler }\n\n  saveToLocalStorage(key: string) {\n    localStorage.setItem(key, JSON.stringify(this.store))\n  }\n  loadFromLocalStorage(key: string) {\n    const store = localStorage.getItem(key)\n    if (store) {\n      this.store = JSON.parse(store) as TStore\n    }\n  }\n\n  sendMessage?: (msg: Message<RequestErrorResponse>) => void\n\n  connect(sendMessage: (msg: Message) => void) {\n    this.sendMessage = sendMessage\n  }\n\n  sendError(\n    payload: RequestErrorResponse,\n    trackId?: string,\n    cancelled?: boolean,\n    timedOut?: boolean,\n  ) {\n    const errorMsg = createMessage({\n      trackId,\n      type: MessageType.Error,\n      name: \"Error\",\n      payload: payload,\n      direction: MessageDirection.ToClient,\n      cancelled,\n      timedOut,\n    })\n    //console.log(\"SERVER: sendError\", errorMsg)\n    this.sendMessage?.(errorMsg)\n  }\n\n  createMessage(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = createMessage({\n      ...opt,\n      direction: MessageDirection.ToClient,\n    })\n    return responseMessage\n  }\n\n  sendResponse(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = this.createMessage(opt)\n    //console.log(\"SERVER: sendResponse\", responseMessage)\n    this.sendMessage?.(responseMessage)\n  }\n\n  sendEvent(name: string, payload: any) {\n    const responseMessage = createMessage({\n      type: MessageType.Event,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    this.sendMessage?.(responseMessage)\n  }\n\n  onMessage(requestMessage: Message | string) {\n    //console.log(\"SERVER: onMessage\", requestMessage)\n    if (typeof requestMessage === \"string\") {\n      try {\n        requestMessage = JSON.parse(requestMessage) as Message\n      } catch (e) {\n        this.sendError({\n          message: `Error parsing message: ${e}`,\n          request: requestMessage,\n          error: e,\n          stack: (e as any)?.stack,\n        })\n        console.error(\"Error parsing message\", e)\n        return\n      }\n    }\n    if (requestMessage.type === \"Command\") {\n      if (!this.commands[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Command ${requestMessage.name} not found (Register it with addCommand)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleCommand(requestMessage)\n    }\n    if (requestMessage.type === \"Query\") {\n      if (!this.queries[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Query ${requestMessage.name} not found (Register it with addQuery)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleQuery(requestMessage)\n    }\n    if (requestMessage.type === \"Event\") {\n      if (!this.eventListeners[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Event ${requestMessage.name} not found (Register it with addEvent)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleEvent(requestMessage)\n    }\n  }\n  serverHandleCommand(requestMessage: Message) {\n    const handler = this.commands[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.CommandResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    try {\n      handler({\n        requestMessage: requestMessage,\n        request: requestMessage.payload,\n        store: this.store,\n        error: sendError,\n        event: fireEvent,\n        response: sendResponse,\n        createResponseMessage,\n        sendResponseMessage,\n      })\n    } catch (e) {\n      sendError({\n        message: `Error in command handler for '${requestMessage.name}'`,\n        requestMessage: requestMessage,\n        error: e,\n        stack: (e as any)?.stack,\n      })\n    }\n  }\n\n  serverHandleQuery(requestMessage: Message) {\n    const handler = this.queries[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.QueryResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n      response: sendResponse,\n      createResponseMessage,\n      sendResponseMessage,\n    })\n  }\n  serverHandleEvent(requestMessage: Message) {\n    const handler = this.eventListeners[requestMessage.name]\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n    })\n  }\n  // In memory message bridge service\n  addCommand<TCommand = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TCommand, TResponse, TStore>,\n  ) {\n    this.commands[name] = handler\n  }\n  addQuery<TQuery = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TQuery, TResponse, TStore>,\n  ) {\n    this.queries[name] = handler\n  }\n  addEventListener<TEvent = any>(\n    name: string,\n    handler: RequestEventHandler<TEvent, void, TStore>,\n  ) {\n    this.eventListeners[name] = handler\n  }\n}\n"],"names":["MessageType","createMessageFromDto","msg","direction","MessageDirection","ToClient","isError","type","Error","Command","CommandResponse","Query","QueryResponse","createMessage","opt","name","payload","trackId","v4","module","schema","created","Date","toISOString","createQueryMessage","createEventMessage","Event","MessageBridgeServiceBase","constructor","wsUri","connected","this","trackedRequestMap","subscribedEventListMap","history","bridgeErrors","options","timeout","undefined","allowResponseValueWhenCancelled","keepHistoryForReceivedMessages","keepHistoryForSendingMessages","logger","console","log","logParseIncomingMessageError","timeoutFromBridgeOptionsMessage","ms","timeoutFromRequestOptionsMessage","logParseIncomingMessageErrorFormat","err","logMessageReceived","logMessageReceivedFormat","logSendingMessage","logSendingMessageFormat","setOptions","getTrackedRequestMessage","requestMessage","cancelRequest","cancelled","onConnect","onError","eventOrData","push","onClose","setOptionalRequestTimeout","onTimeout","reason","timeoutMs","setTimeout","timedOut","responseMessage","request","sendMessageTracked","cancel","requestOptions","sendCancelled","sendCancelledRequest","Promise","resolve","reject","sendMessagePromiseHandler","handleSuccess","response","handleError","throwOnTrackedError","finally","sendMessage","cancelPromiseValue","error","avoidThrowOnNonTrackedError","ToServer","interceptSendMessage","handleErrorMessage","errOpt","optionalTimeId","clearTimeout","resolveWithError","errorMessage","callOnErrorWhenRequestIsCancelled","timeoutErrorMessage","handleCancelOptions","successTrack","handleCancelResponse","callOnSuccessWhenRequestIsCancelled","onSuccess","errorTrack","internalSendMessage","resolveCancel","resolveCancelledForNonTracked","resolveCancelledNonTrackedRequest","subscribeEvent","onEvent","Array","isArray","map","_name","unsubs","forEach","unsub","index","findIndex","x","splice","createTrackedMessage","sendOptions","createdMessage","send","sendTracked","interceptCreatedMessageOptions","createCommand","createCommandMessage","createQuery","sendCommand","sendCommandTracked","sendQuery","sendQueryTracked","createEvent","eventOptions","eventMessage","createdEvent","interceptCreatedEventMessageOptions","sendEvent","onMessage","messageString","messageDto","JSON","parse","e","interceptReceivedMessage","handleIncomingMessage","logData","logSendingMessageFilter","match","onSend","sendNetworkMessage","logMessageReceivedFilter","errorHandled","receiveEventMessage","trackMsg","eventMsg","callback","connection","connect","withUrl","withAutomaticReconnect","build","on","onclose","start","then","catch","close","stop","msgJson","stringify","invoke","toString","WebsocketMessageBridgeService","socket","connectedCallback","WebSocket","addEventListener","event","data","ClientSideMessageBridgeService","server","setServer","msgDetachRef","InMemoryClientSideServer","store","commands","queries","eventListeners","saveToLocalStorage","key","localStorage","setItem","loadFromLocalStorage","getItem","sendError","errorMsg","sendResponse","message","stack","serverHandleCommand","serverHandleQuery","serverHandleEvent","handler","sendResponseMessage","createResponseMessage","fireEvent","addCommand","addQuery"],"mappings":"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"}