{"version":3,"file":"index.modern.mjs","sources":["../src/MessageBridgeTypes.ts","../src/MessageBridgeHelper.ts","../src/MessageBridgeServiceBase.ts","../src/services/SignalRMessageBridgeService.ts","../src/services/WebsocketMessageBridgeService.ts","../src/services/ClientSideMessageBridgeService.ts","../src/services/InMemoryClientSideServer.ts"],"sourcesContent":["// Typescript util\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type OmitAndOptional<\n  T,\n  TOmit extends keyof T,\n  TOpt extends keyof Omit<T, TOmit>,\n> = Pick<Partial<Omit<T, TOmit>>, TOpt> & Omit<Omit<T, TOmit>, TOpt>\n\n// bridge\nexport type BridgeOptions = {\n  // Add listeners:\n  onMessage?: (msg: Message) => void\n  onSend?: (msg: Message) => void\n  onError?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onSuccess?: (msg: RequestResponse) => void\n  onClose?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onConnect?: () => void\n  // Can be used to send a cancel request to the server\n  onCancel?: (msg: Message) => void\n  // Interception:\n  // - can be used to generalize behavior (Happens as early as possible in the process)\n  // Happens just after user options is applied. Before stored in track map and before any other actions.\n  interceptSendMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after message-string parsing, but before stored in history, onMessage and all other actions\n  // To get request for the message use: getTrackedRequestMessage(trackId: string): Message | undefined\n  interceptReceivedMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after the options for createMessage is applied)\n  interceptCreatedMessageOptions?: (msg: CreatedMessage) => CreatedMessage // (default: undefined)\n  interceptCreatedEventMessageOptions?: (msg: CreatedEvent) => CreatedEvent // (default: undefined)\n  // Handle errors and timeouts:\n  avoidThrowOnNonTrackedError?: boolean // (default: undefined)\n  throwOnTrackedError?: boolean // (default: undefined)\n  timeout?: number // (default: undefined)\n  // Cancel\n  // resolve on cancel (Let the process that did the request handle the cancel)\n  resolveCancelledNonTrackedRequest?: boolean // (default: undefined)\n  sendCancelledRequest?: boolean // (default: undefined)\n  callOnErrorWhenRequestIsCancelled?: boolean // (default: undefined)\n  callOnSuccessWhenRequestIsCancelled?: boolean // (default: undefined)\n  // if true, the response can still have a value, else it will be undefined\n  allowResponseValueWhenCancelled?: boolean // (default: undefined)\n  // Debugging options:\n  timeoutFromBridgeOptionsMessage?: (ms: number) => string // (has default implementation)\n  timeoutFromRequestOptionsMessage?: (ms: number) => string // (has default implementation)\n  keepHistoryForReceivedMessages?: boolean // (default: false)\n  keepHistoryForSendingMessages?: boolean // (default: false)\n  logger?: (...data: any[]) => void // set custom logger (default: console?.log)\n  logParseIncomingMessageError?: boolean // (default: true)\n  logParseIncomingMessageErrorFormat?: (err: unknown) => any[] // (has default implementation)\n  logMessageReceived?: boolean // log all messages received\n  logMessageReceivedFormat?: (msg: Message) => any[] // (has default implementation)\n  logSendingMessage?: boolean // log all messages sent\n  logSendingMessageFormat?: (msg: Message) => any[] // (has default implementation)\n  logMessageReceivedFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n  logSendingMessageFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n}\n// enums (These are runtime enums)\nexport enum MessageType {\n  Command = \"Command\",\n  CommandResponse = \"CommandResponse\",\n  Query = \"Query\",\n  QueryResponse = \"QueryResponse\",\n  Event = \"Event\",\n  Error = \"Error\",\n}\n\nexport enum MessageDirection {\n  ToClient = \"ToClient\",\n  ToServer = \"ToServer\",\n}\n\n// types (Not runtime)\nexport type Message<TPayload = any, TSchema = any> = {\n  module?: string\n  name: string\n  type: MessageType\n  isError: boolean\n  cancelled?: boolean\n  timedOut?: boolean\n  trackId: string\n  created: string\n  payload: TPayload\n  schema?: TSchema\n  direction: MessageDirection\n}\n\n// Request\nexport type RequestResponse<TRequest = any, TResponse = any, TError = any> = {\n  response: TResponse\n  request: TRequest\n  responseMessage: Message<TResponse>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  isError?: boolean\n  error?: TError\n  errorMessage?: Message<TError>\n  cancelled?: boolean\n  timedOut?: boolean\n}\n\nexport type RequestOptions<TRequest, TResponse, TError = any> = {\n  name: string\n  payload: TRequest\n  onSuccess?: TrackedOnSuccess<TRequest, TResponse>\n  onError?: TrackedOnError<TRequest, TResponse, TError>\n  module?: string\n  timeout?: number\n  resolveCancelledForNonTracked?: boolean\n  sendCancelled?: boolean\n  callOnErrorWhenRequestIsCancelled?: boolean\n  callOnSuccessWhenRequestIsCancelled?: boolean\n  allowResponseValueWhenCancelled?: boolean\n}\n\nexport type SendMessageOptions<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n\nexport type CreatedMessage<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  trackId: string\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  send: () => Promise<TResponse>\n  sendTracked: () => Promise<RequestResponse<TRequest, TResponse, TError>>\n  cancel: () => void\n}\n\nexport type CreatedEvent<TPayload = any> = {\n  trackId: string\n  requestMessage: Message<TPayload>\n  requestOptions: EventOptions<TPayload>\n  send: () => void\n  cancel: () => void\n}\n\nexport type EventOptions<TPayload = any> = {\n  name: string\n  payload: TPayload\n  module?: string\n  sendCancelled?: boolean\n}\n\nexport type TrackedOnSuccess<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => void\n\nexport type TrackedOnError<TRequest = any, TResponse = any, TError = any> = (\n  opt: RequestResponse<TRequest, TResponse, TError>,\n) => void\n\nexport type SubscribeEvent<TResponse> = (\n  payload: TResponse,\n  eventMessage: Message<TResponse>,\n) => void\n\n// Error\nexport type RequestMaybeNoError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type OnTimeoutHandler<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => void\n\n// Internal Tracked\n// used by tracking (No return value '=> void', it uses promise 'resolve')\nexport type InternalTrackedOnSuccess<TResponse> = (\n  responseMessage: Message<TResponse>,\n) => void\n\nexport type InternalTrackedOnError<TError> = (\n  responseMessage: Message<TError> | undefined,\n) => void\n\nexport type InternalTrackedRequest<TRequest, TResponse, TError = any> = {\n  successTrack: InternalTrackedOnSuccess<TResponse>\n  errorTrack: InternalTrackedOnError<TError>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  OmitAndOptional,\n} from \"./MessageBridgeTypes\"\nimport { v4 } from \"uuid\"\n\nexport function createMessageFromDto<TPayload = any, TSchema = any>(\n  msg: Message<TPayload, TSchema>,\n  direction = MessageDirection.ToClient,\n): Message<TPayload, TSchema> {\n  msg.isError = msg.type === MessageType.Error\n  msg.direction ??= direction\n  return msg\n}\n\nexport function createMessage<TPayload = any | undefined, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TPayload, TSchema>,\n    \"created\" | \"isError\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TPayload, TSchema> {\n  return {\n    name: opt.name,\n    payload: opt.payload,\n    type: opt.type,\n    // optionals\n    direction: opt.direction ?? MessageDirection.ToClient,\n    trackId: opt.trackId ?? v4(),\n    module: opt.module,\n    schema: opt.schema,\n    // alway created\n    created: new Date().toISOString(),\n    isError: opt.type === MessageType.Error,\n  }\n}\n\nexport function createCommandMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TRequest, TSchema> {\n  return createMessage({\n    ...opt,\n    type: MessageType.Command,\n  })\n}\n\nexport function createQueryMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Query,\n  })\n}\n\nexport function createEventMessage<TPayload = any>(\n  opt: OmitAndOptional<\n    Message<TPayload>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage<TPayload>({\n    ...opt,\n    type: MessageType.Event,\n  })\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  RequestResponse,\n  SubscribeEvent,\n  InternalTrackedRequest,\n  OmitAndOptional,\n  OnTimeoutHandler,\n  RequestOptions,\n  BridgeOptions,\n  RequestMaybeNoError,\n  SendMessageOptions,\n  CreatedMessage,\n  CreatedEvent,\n  EventOptions,\n} from \"./MessageBridgeTypes\"\n\nimport {\n  createCommandMessage,\n  createEventMessage,\n  createMessageFromDto,\n  createQueryMessage,\n} from \"./MessageBridgeHelper\"\n\nexport abstract class MessageBridgeServiceBase {\n  connected = false\n  trackedRequestMap: {\n    [trackId: string]: InternalTrackedRequest<any, any>\n  } = {}\n\n  subscribedEventListMap: {\n    [eventName: string]: SubscribeEvent<any>[]\n  } = {}\n\n  history: Message[] = []\n  bridgeErrors: unknown[] /*Error*/ = []\n\n  options: BridgeOptions = {\n    timeout: undefined,\n    allowResponseValueWhenCancelled: false,\n    keepHistoryForReceivedMessages: false,\n    keepHistoryForSendingMessages: false,\n    logger: console?.log ?? (() => {}),\n    logParseIncomingMessageError: true,\n    timeoutFromBridgeOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (BridgeOptions.timeout)`,\n    timeoutFromRequestOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (RequestOptions.timeout)`,\n    logParseIncomingMessageErrorFormat: (err: unknown) => [\n      \"Bridge-Error (parse messageReceived):\",\n      err,\n    ],\n    logMessageReceived: false,\n    logMessageReceivedFormat: (msg: Message) => [\"Bridge (messageReceived):\", msg],\n    logSendingMessage: false,\n    logSendingMessageFormat: (msg: Message) => [\"Bridge (sendingMessage):\", msg],\n  }\n\n  constructor(public wsUri: string) {}\n\n  abstract connect(options?: unknown): Promise<void>\n  abstract close(): void\n  abstract sendNetworkMessage(msg: Message): void\n\n  setOptions(opt: BridgeOptions) {\n    this.options = { ...this.options, ...opt }\n  }\n\n  getTrackedRequestMessage(trackId: string): Message | undefined {\n    return this.trackedRequestMap[trackId]?.requestMessage\n  }\n\n  // This will not cancel the request itself (on the server),\n  // but set a cancel flag on the trackMap (so the response will be ignored)\n  cancelRequest(trackId: string): void {\n    if (this.trackedRequestMap[trackId]) {\n      this.trackedRequestMap[trackId].requestMessage.cancelled = true\n    }\n  }\n\n  // the following methods can overwritten with class inheritance\n  // but should override version should call super.methodName()\n  protected onConnect() {\n    this.connected = true\n    this.options.onConnect?.()\n  }\n  protected onError(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.options.onError?.(err, eventOrData)\n  }\n  protected onClose(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.connected = false\n    this.options.onClose?.(err, eventOrData)\n  }\n\n  // base methods (should mostly not be overwritten)\n  protected setOptionalRequestTimeout<TRequest = any, TSchema = any>({\n    requestMessage,\n    timeout,\n    onTimeout,\n  }: {\n    requestMessage: Message<TRequest, TSchema>\n    timeout: number | undefined\n    onTimeout: OnTimeoutHandler<string, TRequest>\n  }) {\n    let reason: string\n    let timeoutMs: number | undefined\n\n    if (timeout !== undefined) {\n      reason =\n        this.options.timeoutFromRequestOptionsMessage?.(timeout) ??\n        `timeout after ${timeout}`\n      timeoutMs = timeout\n    } else if (this.options.timeout !== undefined) {\n      reason =\n        this.options.timeoutFromBridgeOptionsMessage?.(this.options.timeout) ??\n        `timeout after ${this.options.timeout}`\n      timeoutMs = this.options.timeout\n    }\n\n    if (timeoutMs === undefined) {\n      return\n    }\n    return setTimeout(() => {\n      requestMessage.timedOut = true\n      const opt: RequestMaybeNoError<string, TRequest> = {\n        reason,\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n      }\n      onTimeout(opt)\n    }, timeoutMs)\n  }\n\n  sendMessageTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        // check cancel\n        const cancelPromiseValue = {\n          request: opt.requestMessage.payload,\n          requestMessage: opt.requestMessage,\n          cancelled: true,\n          //responseMessage: undefined\n          //response: undefined,\n        } as RequestResponse<TRequest, TResponse, TError>\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<RequestResponse<TRequest, TResponse, TError>>(\n      (resolve, reject) => {\n        this.sendMessagePromiseHandler({\n          ...opt,\n          handleSuccess: (cancelled, response) => {\n            resolve(response)\n          },\n          handleError: (cancelled, response) => {\n            if (this.options.throwOnTrackedError) {\n              reject(response)\n            } else {\n              resolve(response)\n            }\n          },\n        })\n      },\n    ).finally(() => {\n      delete this.trackedRequestMap[opt.requestMessage.trackId]\n    })\n  }\n\n  /**\n   * Only resolve the promise with the TResponse (not the tracked/full response)\n   * onSuccess contains the response in the first argument (and the the tracked/full response in the second argument)\n   */\n  sendMessage<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    // check cancel\n    const cancelPromiseValue = undefined as TResponse\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<TResponse>((resolve, reject) => {\n      this.sendMessagePromiseHandler({\n        ...opt,\n        handleSuccess: (cancelled, response) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n            return\n          }\n          resolve(response.response)\n        },\n        handleError: (cancelled, response, error) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n          }\n          if (this.options.avoidThrowOnNonTrackedError) {\n            //@ts-ignore (The response is not the correct type, but we ignore it)\n            resolve(error?.payload)\n          } else {\n            reject(response)\n          }\n        },\n      })\n    })\n  }\n\n  protected sendMessagePromiseHandler<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >({\n    handleError,\n    handleSuccess,\n    requestMessage,\n    requestOptions,\n  }: SendMessageOptions<TRequest, TResponse, TError, TSchema> & {\n    handleError: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n      error?: RequestMaybeNoError<any, TRequest>,\n    ) => void\n    handleSuccess: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n    ) => void\n  }) {\n    requestMessage.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      requestMessage = this.options.interceptSendMessage(requestMessage)\n    }\n\n    // handle error and timeout\n    const handleErrorMessage = (\n      cancelled: boolean,\n      errOpt: RequestMaybeNoError<any, TRequest>,\n    ) => {\n      if (optionalTimeId) {\n        clearTimeout(optionalTimeId)\n      }\n\n      // resolve with error\n      const resolveWithError: RequestResponse<TRequest, TResponse, TError> = {\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        response: undefined,\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n        isError: true,\n        error: errOpt.reason,\n        errorMessage: errOpt.responseMessage,\n        cancelled:\n          requestMessage.cancelled ||\n          errOpt.requestMessage?.cancelled ||\n          errOpt.responseMessage?.cancelled,\n        timedOut:\n          requestMessage.timedOut ||\n          errOpt.requestMessage?.timedOut ||\n          errOpt.responseMessage?.timedOut,\n      }\n      if (\n        !cancelled ||\n        !this.options.callOnErrorWhenRequestIsCancelled ||\n        !requestOptions.callOnErrorWhenRequestIsCancelled\n      ) {\n        this.onError(resolveWithError)\n        requestOptions.onError?.(resolveWithError)\n      }\n      handleError(cancelled, resolveWithError, errOpt)\n    }\n    // set timeout if needed\n    const optionalTimeId = this.setOptionalRequestTimeout({\n      requestMessage,\n      timeout: requestOptions.timeout,\n      onTimeout: (timeoutErrorMessage) => {\n        const cancelled = this.handleCancelOptions(requestOptions, requestMessage)\n        handleErrorMessage(cancelled, timeoutErrorMessage)\n      },\n    })\n    // add to subscribedTrackIdMap\n    const track: InternalTrackedRequest<TRequest, TResponse, TError> = {\n      successTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestResponse<TRequest, TResponse, TError> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          response: response as TResponse,\n          responseMessage,\n          requestOptions,\n          request: requestMessage.payload,\n          requestMessage,\n          isError: false,\n          cancelled: requestMessage.cancelled || responseMessage.cancelled,\n          timedOut: requestMessage.timedOut || responseMessage.timedOut,\n        }\n        if (optionalTimeId) {\n          clearTimeout(optionalTimeId)\n        }\n\n        if (\n          !cancelled ||\n          !!this.options.callOnSuccessWhenRequestIsCancelled ||\n          !!requestOptions.callOnSuccessWhenRequestIsCancelled\n        ) {\n          this.options.onSuccess?.(opt)\n          requestOptions.onSuccess?.(opt)\n        }\n        handleSuccess(cancelled, opt)\n      },\n      errorTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestMaybeNoError<TError, TRequest> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          reason: response as TError,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n        }\n        handleErrorMessage(cancelled, opt)\n      },\n      requestMessage: requestMessage,\n      requestOptions,\n    }\n    this.trackedRequestMap[requestMessage.trackId] = track\n\n    // send message\n    this.internalSendMessage(requestMessage)\n  }\n\n  private handleCancelOptions<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    let resolveCancel = false\n    if (requestOptions.resolveCancelledForNonTracked !== undefined) {\n      resolveCancel = requestOptions.resolveCancelledForNonTracked\n    } else if (this.options.resolveCancelledNonTrackedRequest) {\n      resolveCancel = true\n    }\n    let cancelled = false\n    if (responseMessage?.cancelled || requestMessage.cancelled) {\n      cancelled = true\n    }\n    if (resolveCancel && cancelled) {\n      cancelled = false\n    }\n    return cancelled\n  }\n\n  private handleCancelResponse<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    const cancelled = this.handleCancelOptions(\n      requestOptions,\n      requestMessage,\n      responseMessage,\n    )\n    let response = responseMessage?.payload\n    if (cancelled) {\n      if (requestOptions.allowResponseValueWhenCancelled !== undefined) {\n        if (requestOptions.allowResponseValueWhenCancelled !== true) {\n          response = undefined as TResponse\n        }\n      } else if (this.options.allowResponseValueWhenCancelled !== true) {\n        response = undefined as TResponse\n      }\n    }\n    return { response, cancelled }\n  }\n\n  subscribeEvent<TResponse = any>({\n    name,\n    onEvent,\n  }: {\n    name: string | string[]\n    onEvent: SubscribeEvent<TResponse>\n  }): () => void {\n    if (Array.isArray(name)) {\n      const unsubs = name.map((_name) => this.subscribeEvent({ name: _name, onEvent }))\n      return () => unsubs.forEach((unsub) => unsub())\n    }\n    if (!this.subscribedEventListMap[name]) this.subscribedEventListMap[name] = []\n    this.subscribedEventListMap[name].push(onEvent)\n    return () => {\n      const index = this.subscribedEventListMap[name].findIndex((x) => x === onEvent)\n      this.subscribedEventListMap[name].splice(index, 1)\n    }\n  }\n\n  private createTrackedMessage<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    sendOptions: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const trackId = sendOptions.requestMessage.trackId\n    let createdMessage: CreatedMessage = {\n      trackId: trackId,\n      requestMessage: sendOptions.requestMessage,\n      requestOptions: sendOptions.requestOptions,\n      send: () => this.sendMessage(sendOptions),\n      sendTracked: () => this.sendMessageTracked(sendOptions),\n      cancel: () => {\n        // before run\n        if (sendOptions?.requestMessage) {\n          sendOptions.requestMessage.cancelled = true\n        }\n        // running\n        this.cancelRequest(trackId)\n      },\n    }\n    if (this.options.interceptCreatedMessageOptions) {\n      createdMessage = this.options.interceptCreatedMessageOptions(createdMessage)\n    }\n    return createdMessage\n  }\n\n  createCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createCommandMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  createQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createQueryMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  sendCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendCommandTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  sendQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendQueryTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  createEvent<TPayload = any>(\n    eventOptions: EventOptions<TPayload>,\n  ): CreatedEvent<TPayload> {\n    let eventMessage = createEventMessage<TPayload>(eventOptions)\n    eventMessage.direction = MessageDirection.ToServer\n    let createdEvent: CreatedEvent = {\n      trackId: eventMessage.trackId,\n      requestMessage: eventMessage,\n      requestOptions: eventOptions,\n      cancel: () => {\n        // before run\n        if (eventMessage) {\n          eventMessage.cancelled = true\n        }\n      },\n      send: () => {\n        if (eventMessage.cancelled) {\n          if (eventOptions.sendCancelled !== undefined) {\n            if (!eventOptions.sendCancelled) {\n              return\n            }\n          } else if (!this.options.sendCancelledRequest) {\n            return\n          }\n        }\n        if (this.options.interceptSendMessage) {\n          eventMessage = this.options.interceptSendMessage(eventMessage)\n        }\n        this.internalSendMessage(eventMessage)\n      },\n    }\n    if (this.options.interceptCreatedEventMessageOptions) {\n      createdEvent = this.options.interceptCreatedEventMessageOptions(createdEvent)\n    }\n\n    return createdEvent\n  }\n\n  sendEvent<TPayload = any>(\n    eventOptions: OmitAndOptional<\n      Message<TPayload>,\n      \"trackId\" | \"created\" | \"isError\" | \"type\",\n      \"direction\"\n    >,\n  ) {\n    return this.createEvent<TPayload>(eventOptions).send()\n  }\n\n  protected onMessage(messageString: string | Message) {\n    //console.log(\"onMessage\", messageString)\n    let messageDto: Message\n    try {\n      messageDto =\n        typeof messageString === \"string\"\n          ? (JSON.parse(messageString) as Message)\n          : messageString\n    } catch (e) {\n      this.onError(e as Error)\n      //console.log(\"Incorrect message received: \" + messageString)\n      return\n    }\n    try {\n      let msg = createMessageFromDto(messageDto)\n      if (this.options.interceptReceivedMessage) {\n        msg = this.options.interceptReceivedMessage(msg)\n      }\n      this.handleIncomingMessage(msg)\n    } catch (e) {\n      this.onError(e as Error)\n      if (this.options.logger && this.options.logParseIncomingMessageError) {\n        const logData = this.options.logParseIncomingMessageErrorFormat?.(messageDto) ?? [\n          e,\n        ]\n        this.options.logger(logData)\n      }\n    }\n  }\n\n  protected internalSendMessage(msg: Message) {\n    if (this.options.keepHistoryForSendingMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logSendingMessage) {\n      let log = true\n      if (this.options.logSendingMessageFilter) {\n        log = !!msg.name.match(this.options.logSendingMessageFilter)\n      }\n      if (log) {\n        const logData = this.options.logSendingMessageFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onSend?.(msg)\n    this.sendNetworkMessage(msg)\n  }\n\n  protected handleIncomingMessage(msg: Message) {\n    //console.log(\"handleIncomingMessage\", msg)\n    if (this.options.keepHistoryForReceivedMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logMessageReceived) {\n      let log = true\n      if (this.options.logMessageReceivedFilter) {\n        log = !!msg.name.match(this.options.logMessageReceivedFilter)\n      }\n      if (log) {\n        const logData = this.options.logMessageReceivedFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onMessage?.(msg)\n\n    let errorHandled = msg.type !== MessageType.Error\n\n    if (msg.type === MessageType.Event) {\n      this.receiveEventMessage(msg)\n      return\n    }\n    const trackMsg = this.trackedRequestMap[msg.trackId]\n    if (trackMsg) {\n      if (msg.type === MessageType.Error) {\n        trackMsg.errorTrack(msg)\n        errorHandled = true\n      } else {\n        trackMsg.successTrack(msg)\n      }\n      delete this.trackedRequestMap[msg.trackId]\n    }\n\n    if (!errorHandled) {\n      this.onError?.(msg)\n    }\n  }\n\n  protected receiveEventMessage(eventMsg: Message) {\n    if (this.subscribedEventListMap[eventMsg.name]) {\n      this.subscribedEventListMap[eventMsg.name].forEach((callback) =>\n        callback(eventMsg.payload, eventMsg),\n      )\n    }\n  }\n}\n","import { HubConnectionBuilder } from \"@microsoft/signalr\"\nimport { IHttpConnectionOptions } from \"@microsoft/signalr/src/IHttpConnectionOptions\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class SignalRMessageBridgeService extends MessageBridgeServiceBase {\n  connection?: signalR.HubConnection\n  connect(options: IHttpConnectionOptions = {}): Promise<void> {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.wsUri, options)\n      .withAutomaticReconnect()\n      .build()\n    if (!this.connection) {\n      throw new Error(\"Failed to create SignalR connection\")\n    }\n    this.connection.on(\"ReceiveMessage\", (messageString: string | Message) => {\n      this.onMessage(messageString)\n    })\n    this.connection.onclose((error) => {\n      this.onClose(error)\n    })\n    return this.connection\n      .start()\n      .then(() => {\n        this.onConnect()\n      })\n      .catch((err: Error) => {\n        this.onError(err)\n      })\n  }\n\n  close() {\n    this.connection?.stop()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.connection?.invoke(\"SendMessage\", msgJson).catch((err) => {\n      this.onError(err as Error)\n      return console.error(err.toString())\n    })\n  }\n}\n","import { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class WebsocketMessageBridgeService extends MessageBridgeServiceBase {\n  socket?: WebSocket\n  connectedCallback?: () => void\n\n  connect() {\n    this.socket = new WebSocket(this.wsUri)\n    this.socket.addEventListener(\"message\", (event) => {\n      const messageString: string | Message = event.data\n      this.onMessage(messageString)\n    })\n    this.socket.addEventListener(\"close\", (event) => {\n      this.onClose(event.reason, event)\n    })\n    this.socket.addEventListener(\"error\", (event) => {\n      this.onError(event, event)\n    })\n\n    return new Promise<void>((resolve, reject) => {\n      // Connection opened\n      this.socket?.addEventListener(\"open\", (event) => {\n        this.onConnect()\n        resolve()\n      })\n    })\n  }\n  close(): void {\n    this.socket?.close()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.socket?.send(msgJson)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\n\nexport type MessageBridgeClientServer = {\n  onMessage: (msg: Message) => void\n  connect: (sendMessage: (msg: Message) => void) => void\n}\n\nexport class ClientSideMessageBridgeService extends MessageBridgeServiceBase {\n  server?: MessageBridgeClientServer\n  setServer(server: MessageBridgeClientServer) {\n    this.server = server\n  }\n  connect() {\n    if (!this.server) {\n      throw new Error(\"No server set\")\n    }\n    this.server?.connect((msg) => {\n      // ensure that no object reference is passed to the client\n      const msgDetachRef = JSON.parse(JSON.stringify(msg))\n      this.onMessage(msgDetachRef)\n      this.onConnect()\n    })\n    return Promise.resolve()\n  }\n  close() {\n    this.onClose()\n  }\n  sendNetworkMessage(msg: Message) {\n    // ensure that no object reference is passed to the server\n    const msgDetachRef = JSON.parse(JSON.stringify(msg))\n    setTimeout(() => {\n      this.server?.onMessage(msgDetachRef)\n    }, 10)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\nimport { MessageBridgeClientServer } from \"./ClientSideMessageBridgeService\"\n\nexport type RequestErrorResponse = {\n  message: string\n  request?: Message | string\n  stack?: string\n  error?: unknown\n}\n\nexport type RequestHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any, cancelled?: boolean, timedOut?: boolean) => void\n  response: (response: TResponse) => void\n  sendResponseMessage: (responseMessage: Message<TRequest, TResponse>) => void\n  createResponseMessage(response: TResponse): Message<TRequest, TResponse>\n}) => void\n\nexport type RequestEventHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n}) => void\n\nexport class InMemoryClientSideServer<TStore> implements MessageBridgeClientServer {\n  store = {} as TStore\n  commands = {} as { [name: string]: RequestHandler }\n  queries = {} as { [name: string]: RequestHandler }\n  eventListeners = {} as { [name: string]: RequestEventHandler }\n\n  saveToLocalStorage(key: string) {\n    localStorage.setItem(key, JSON.stringify(this.store))\n  }\n  loadFromLocalStorage(key: string) {\n    const store = localStorage.getItem(key)\n    if (store) {\n      this.store = JSON.parse(store) as TStore\n    }\n  }\n\n  sendMessage?: (msg: Message<RequestErrorResponse>) => void\n\n  connect(sendMessage: (msg: Message) => void) {\n    this.sendMessage = sendMessage\n  }\n\n  sendError(\n    payload: RequestErrorResponse,\n    trackId?: string,\n    cancelled?: boolean,\n    timedOut?: boolean,\n  ) {\n    const errorMsg = createMessage({\n      trackId,\n      type: MessageType.Error,\n      name: \"Error\",\n      payload: payload,\n      direction: MessageDirection.ToClient,\n      cancelled,\n      timedOut,\n    })\n    //console.log(\"SERVER: sendError\", errorMsg)\n    this.sendMessage?.(errorMsg)\n  }\n\n  createMessage(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = createMessage({\n      ...opt,\n      direction: MessageDirection.ToClient,\n    })\n    return responseMessage\n  }\n\n  sendResponse(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = this.createMessage(opt)\n    //console.log(\"SERVER: sendResponse\", responseMessage)\n    this.sendMessage?.(responseMessage)\n  }\n\n  sendEvent(name: string, payload: any) {\n    const responseMessage = createMessage({\n      type: MessageType.Event,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    this.sendMessage?.(responseMessage)\n  }\n\n  onMessage(requestMessage: Message | string) {\n    //console.log(\"SERVER: onMessage\", requestMessage)\n    if (typeof requestMessage === \"string\") {\n      try {\n        requestMessage = JSON.parse(requestMessage) as Message\n      } catch (e) {\n        this.sendError({\n          message: `Error parsing message: ${e}`,\n          request: requestMessage,\n          error: e,\n          stack: (e as any)?.stack,\n        })\n        console.error(\"Error parsing message\", e)\n        return\n      }\n    }\n    if (requestMessage.type === \"Command\") {\n      if (!this.commands[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Command ${requestMessage.name} not found (Register it with addCommand)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleCommand(requestMessage)\n    }\n    if (requestMessage.type === \"Query\") {\n      if (!this.queries[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Query ${requestMessage.name} not found (Register it with addQuery)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleQuery(requestMessage)\n    }\n    if (requestMessage.type === \"Event\") {\n      if (!this.eventListeners[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Event ${requestMessage.name} not found (Register it with addEvent)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleEvent(requestMessage)\n    }\n  }\n  serverHandleCommand(requestMessage: Message) {\n    const handler = this.commands[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.CommandResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    try {\n      handler({\n        requestMessage: requestMessage,\n        request: requestMessage.payload,\n        store: this.store,\n        error: sendError,\n        event: fireEvent,\n        response: sendResponse,\n        createResponseMessage,\n        sendResponseMessage,\n      })\n    } catch (e) {\n      sendError({\n        message: `Error in command handler for '${requestMessage.name}'`,\n        requestMessage: requestMessage,\n        error: e,\n        stack: (e as any)?.stack,\n      })\n    }\n  }\n\n  serverHandleQuery(requestMessage: Message) {\n    const handler = this.queries[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.QueryResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n      response: sendResponse,\n      createResponseMessage,\n      sendResponseMessage,\n    })\n  }\n  serverHandleEvent(requestMessage: Message) {\n    const handler = this.eventListeners[requestMessage.name]\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n    })\n  }\n  // In memory message bridge service\n  addCommand<TCommand = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TCommand, TResponse, TStore>,\n  ) {\n    this.commands[name] = handler\n  }\n  addQuery<TQuery = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TQuery, TResponse, TStore>,\n  ) {\n    this.queries[name] = handler\n  }\n  addEventListener<TEvent = any>(\n    name: string,\n    handler: RequestEventHandler<TEvent, void, TStore>,\n  ) {\n    this.eventListeners[name] = handler\n  }\n}\n"],"names":["MessageType","createMessageFromDto","msg","direction","MessageDirection","ToClient","isError","type","Error","opt","_opt$direction","_opt$trackId","name","payload","trackId","v4","module","schema","created","toISOString","createCommandMessage","createMessage","_extends","Command","Query","createEventMessage","Event","MessageBridgeServiceBase","constructor","wsUri","connected","this","trackedRequestMap","subscribedEventListMap","history","bridgeErrors","options","timeout","undefined","allowResponseValueWhenCancelled","keepHistoryForReceivedMessages","keepHistoryForSendingMessages","logger","console","_console","log","_console$log","logParseIncomingMessageError","timeoutFromBridgeOptionsMessage","ms","timeoutFromRequestOptionsMessage","logParseIncomingMessageErrorFormat","err","logMessageReceived","logMessageReceivedFormat","logSendingMessage","logSendingMessageFormat","setOptions","getTrackedRequestMessage","_this$trackedRequestM","requestMessage","cancelRequest","cancelled","onConnect","_this$options$onConne","_this$options","call","onError","eventOrData","_this$options$onError","_this$options2","push","onClose","_this$options$onClose","_this$options3","setOptionalRequestTimeout","onTimeout","reason","timeoutMs","_this$options$timeout","_this$options$timeout2","_this$options4","_this$options$timeout3","_this$options$timeout4","_this$options5","setTimeout","timedOut","responseMessage","request","sendMessageTracked","cancel","requestOptions","sendCancelled","sendCancelledRequest","Promise","resolve","reject","sendMessagePromiseHandler","handleSuccess","response","handleError","throwOnTrackedError","finally","sendMessage","cancelPromiseValue","error","avoidThrowOnNonTrackedError","ToServer","interceptSendMessage","handleErrorMessage","errOpt","optionalTimeId","clearTimeout","resolveWithError","errorMessage","_errOpt$requestMessag","_errOpt$responseMessa","_errOpt$requestMessag2","_errOpt$responseMessa2","callOnErrorWhenRequestIsCancelled","timeoutErrorMessage","handleCancelOptions","successTrack","handleCancelResponse","_this$options$onSucce","_this$options6","callOnSuccessWhenRequestIsCancelled","onSuccess","errorTrack","internalSendMessage","resolveCancel","resolveCancelledForNonTracked","resolveCancelledNonTrackedRequest","subscribeEvent","onEvent","Array","isArray","unsubs","map","_name","forEach","unsub","index","findIndex","x","splice","createTrackedMessage","sendOptions","createdMessage","send","sendTracked","interceptCreatedMessageOptions","createCommand","createQuery","createQueryMessage","sendCommand","sendCommandTracked","sendQuery","sendQueryTracked","createEvent","eventOptions","eventMessage","createdEvent","interceptCreatedEventMessageOptions","sendEvent","onMessage","messageString","messageDto","JSON","parse","e","interceptReceivedMessage","handleIncomingMessage","_this$options$logPars","_this$options$logPars2","_this$options7","logData","_this$options$onSend","_this$options9","logSendingMessageFilter","match","_this$options$logSend","_this$options$logSend2","_this$options8","onSend","sendNetworkMessage","_this$options$onMessa","_this$options11","logMessageReceivedFilter","_this$options$logMess","_this$options$logMess2","_this$options10","errorHandled","receiveEventMessage","trackMsg","_this$onError","eventMsg","callback","connection","connect","withUrl","withAutomaticReconnect","build","on","onclose","start","then","catch","close","_this$connection","stop","_this$connection2","msgJson","stringify","invoke","toString","WebsocketMessageBridgeService","socket","connectedCallback","WebSocket","addEventListener","event","data","_this$socket","_this$socket2","_this$socket3","ClientSideMessageBridgeService","server","setServer","_this$server","msgDetachRef","_this$server2","InMemoryClientSideServer","store","commands","queries","eventListeners","saveToLocalStorage","key","localStorage","setItem","loadFromLocalStorage","getItem","sendError","_this$sendMessage","errorMsg","sendResponse","_this$sendMessage2","_this$sendMessage3","message","stack","serverHandleCommand","serverHandleQuery","serverHandleEvent","handler","sendResponseMessage","_this$sendMessage4","createResponseMessage","CommandResponse","fireEvent","QueryResponse","addCommand","addQuery"],"mappings":"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"}