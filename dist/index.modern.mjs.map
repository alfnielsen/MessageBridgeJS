{"version":3,"file":"index.modern.mjs","sources":["../src/MessageBridgeTypes.ts","../src/MessageBridgeHelper.ts","../src/MessageBridgeServiceBase.ts","../src/services/SignalRMessageBridgeService.ts","../src/services/WebsocketMessageBridgeService.ts","../src/services/ClientSideMessageBridgeService.ts","../src/services/InMemoryClientSideServer.ts"],"sourcesContent":["// Typescript util\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type OmitAndOptional<\n  T,\n  TOmit extends keyof T,\n  TOpt extends keyof Omit<T, TOmit>,\n> = Pick<Partial<Omit<T, TOmit>>, TOpt> & Omit<Omit<T, TOmit>, TOpt>\n\n// bridge\nexport type BridgeOptions = {\n  // Add listeners:\n  onMessage?: (msg: Message) => void\n  onSend?: (msg: Message) => void\n  onError?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onSuccess?: (msg: RequestResponse) => void\n  onClose?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onConnect?: () => void\n  // Can be used to send a cancel request to the server\n  onCancel?: (msg: Message) => void\n  // Interception:\n  // - can be used to generalize behavior (Happens as early as possible in the process)\n  // Happens just after user options is applied. Before stored in track map and before any other actions.\n  interceptSendMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after message-string parsing, but before stored in history, onMessage and all other actions\n  // To get request for the message use: getTrackedRequestMessage(trackId: string): Message | undefined\n  interceptReceivedMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after the options for createMessage is applied)\n  interceptCreatedMessageOptions?: (msg: CreatedMessage) => CreatedMessage // (default: undefined)\n  interceptCreatedEventMessageOptions?: (msg: CreatedEvent) => CreatedEvent // (default: undefined)\n  // Handle errors and timeouts:\n  avoidThrowOnNonTrackedError?: boolean // (default: undefined)\n  throwOnTrackedError?: boolean // (default: undefined)\n  timeout?: number // (default: undefined)\n  // Cancel\n  // resolve on cancel (Let the process that did the request handle the cancel)\n  resolveCancelledNonTrackedRequest?: boolean // (default: undefined)\n  sendCancelledRequest?: boolean // (default: undefined)\n  callOnErrorWhenRequestIsCancelled?: boolean // (default: undefined)\n  callOnSuccessWhenRequestIsCancelled?: boolean // (default: undefined)\n  // if true, the response can still have a value, else it will be undefined\n  allowResponseValueWhenCancelled?: boolean // (default: undefined)\n  // Debugging options:\n  timeoutFromBridgeOptionsMessage?: (ms: number) => string // (has default implementation)\n  timeoutFromRequestOptionsMessage?: (ms: number) => string // (has default implementation)\n  keepHistoryForReceivedMessages?: boolean // (default: false)\n  keepHistoryForSendingMessages?: boolean // (default: false)\n  logger?: (...data: any[]) => void // set custom logger (default: console?.log)\n  logParseIncomingMessageError?: boolean // (default: true)\n  logParseIncomingMessageErrorFormat?: (err: unknown) => any[] // (has default implementation)\n  logMessageReceived?: boolean // log all messages received\n  logMessageReceivedFormat?: (msg: Message) => any[] // (has default implementation)\n  logSendingMessage?: boolean // log all messages sent\n  logSendingMessageFormat?: (msg: Message) => any[] // (has default implementation)\n  logMessageReceivedFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n  logSendingMessageFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n}\n// enums (These are runtime enums)\nexport enum MessageType {\n  Command = \"Command\",\n  CommandResponse = \"CommandResponse\",\n  Query = \"Query\",\n  QueryResponse = \"QueryResponse\",\n  Event = \"Event\",\n  Error = \"Error\",\n}\n\nexport enum MessageDirection {\n  ToClient = \"ToClient\",\n  ToServer = \"ToServer\",\n}\n\n// types (Not runtime)\nexport type Message<TPayload = any, TSchema = any> = {\n  module?: string\n  name: string\n  type: MessageType\n  isError: boolean\n  cancelled?: boolean\n  timedOut?: boolean\n  trackId: string\n  created: string\n  payload: TPayload\n  schema?: TSchema\n  direction: MessageDirection\n}\n\n// Request\nexport type RequestResponse<TRequest = any, TResponse = any, TError = any> = {\n  response: TResponse\n  request: TRequest\n  responseMessage: Message<TResponse>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  isError?: boolean\n  error?: TError\n  errorMessage?: Message<TError>\n  cancelled?: boolean\n  timedOut?: boolean\n}\n\nexport type RequestOptions<TRequest, TResponse, TError = any> = {\n  name: string\n  payload: TRequest\n  onSuccess?: TrackedOnSuccess<TRequest, TResponse>\n  onError?: TrackedOnError<TRequest, TResponse, TError>\n  module?: string\n  timeout?: number\n  resolveCancelledForNonTracked?: boolean\n  sendCancelled?: boolean\n  callOnErrorWhenRequestIsCancelled?: boolean\n  callOnSuccessWhenRequestIsCancelled?: boolean\n  allowResponseValueWhenCancelled?: boolean\n}\n\nexport type SendMessageOptions<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n\nexport type CreatedMessage<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  trackId: string\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  send: () => Promise<TResponse>\n  sendTracked: () => Promise<RequestResponse<TRequest, TResponse, TError>>\n  cancel: () => void\n}\n\nexport type CreatedEvent<TPayload = any> = {\n  trackId: string\n  requestMessage: Message<TPayload>\n  requestOptions: EventOptions<TPayload>\n  send: () => void\n  cancel: () => void\n}\n\nexport type EventOptions<TPayload = any> = {\n  name: string\n  payload: TPayload\n  module?: string\n  sendCancelled?: boolean\n}\n\nexport type TrackedOnSuccess<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => void\n\nexport type TrackedOnError<TRequest = any, TResponse = any, TError = any> = (\n  opt: RequestResponse<TRequest, TResponse, TError>,\n) => void\n\nexport type SubscribeEvent<TResponse> = (\n  payload: TResponse,\n  eventMessage: Message<TResponse>,\n) => void\n\n// Error\nexport type RequestMaybeNoError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type OnTimeoutHandler<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => void\n\n// Internal Tracked\n// used by tracking (No return value '=> void', it uses promise 'resolve')\nexport type InternalTrackedOnSuccess<TResponse> = (\n  responseMessage: Message<TResponse>,\n) => void\n\nexport type InternalTrackedOnError<TError> = (\n  responseMessage: Message<TError> | undefined,\n) => void\n\nexport type InternalTrackedRequest<TRequest, TResponse, TError = any> = {\n  successTrack: InternalTrackedOnSuccess<TResponse>\n  errorTrack: InternalTrackedOnError<TError>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  OmitAndOptional,\n} from \"./MessageBridgeTypes\"\nimport { v4 } from \"uuid\"\n\nexport function createMessageFromDto<TPayload = any, TSchema = any>(\n  msg: Message<TPayload, TSchema>,\n  direction = MessageDirection.ToClient,\n): Message<TPayload, TSchema> {\n  msg.isError = msg.type === MessageType.Error\n  msg.direction ??= direction\n  return msg\n}\n\nexport function createMessage<TPayload = any | undefined, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TPayload, TSchema>,\n    \"created\" | \"isError\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TPayload, TSchema> {\n  return {\n    name: opt.name,\n    payload: opt.payload,\n    type: opt.type,\n    // optionals\n    direction: opt.direction ?? MessageDirection.ToClient,\n    trackId: opt.trackId ?? v4(),\n    module: opt.module,\n    schema: opt.schema,\n    // alway created\n    created: new Date().toISOString(),\n    isError: opt.type === MessageType.Error,\n  }\n}\n\nexport function createCommandMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TRequest, TSchema> {\n  return createMessage({\n    ...opt,\n    type: MessageType.Command,\n  })\n}\n\nexport function createQueryMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Query,\n  })\n}\n\nexport function createEventMessage<TPayload = any>(\n  opt: OmitAndOptional<\n    Message<TPayload>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage<TPayload>({\n    ...opt,\n    type: MessageType.Event,\n  })\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  RequestResponse,\n  SubscribeEvent,\n  InternalTrackedRequest,\n  OmitAndOptional,\n  OnTimeoutHandler,\n  RequestOptions,\n  BridgeOptions,\n  RequestMaybeNoError,\n  SendMessageOptions,\n  CreatedMessage,\n  CreatedEvent,\n  EventOptions,\n} from \"./MessageBridgeTypes\"\n\nimport {\n  createCommandMessage,\n  createEventMessage,\n  createMessageFromDto,\n  createQueryMessage,\n} from \"./MessageBridgeHelper\"\n\nexport abstract class MessageBridgeServiceBase {\n  connected = false\n  trackedRequestMap: {\n    [trackId: string]: InternalTrackedRequest<any, any>\n  } = {}\n\n  subscribedEventListMap: {\n    [eventName: string]: SubscribeEvent<any>[]\n  } = {}\n\n  history: Message[] = []\n  bridgeErrors: unknown[] /*Error*/ = []\n\n  options: BridgeOptions = {\n    timeout: undefined,\n    allowResponseValueWhenCancelled: false,\n    keepHistoryForReceivedMessages: false,\n    keepHistoryForSendingMessages: false,\n    logger: (...data: any[]) => console?.log ?? (() => {}),\n    logParseIncomingMessageError: true,\n    timeoutFromBridgeOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (BridgeOptions.timeout)`,\n    timeoutFromRequestOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (RequestOptions.timeout)`,\n    logParseIncomingMessageErrorFormat: (err: unknown) => [\n      \"Bridge-Error (parse messageReceived):\",\n      err,\n    ],\n    logMessageReceived: false,\n    logMessageReceivedFormat: (msg: Message) => [\"Bridge (messageReceived):\", msg],\n    logSendingMessage: false,\n    logSendingMessageFormat: (msg: Message) => [\"Bridge (sendingMessage):\", msg],\n  }\n\n  constructor(public wsUri: string) {}\n\n  abstract connect(options?: unknown): Promise<void>\n  abstract close(): void\n  abstract sendNetworkMessage(msg: Message): void\n\n  setOptions(opt: BridgeOptions) {\n    this.options = { ...this.options, ...opt }\n  }\n\n  getTrackedRequestMessage(trackId: string): Message | undefined {\n    return this.trackedRequestMap[trackId]?.requestMessage\n  }\n\n  // This will not cancel the request itself (on the server),\n  // but set a cancel flag on the trackMap (so the response will be ignored)\n  cancelRequest(trackId: string): void {\n    if (this.trackedRequestMap[trackId]) {\n      this.trackedRequestMap[trackId].requestMessage.cancelled = true\n    }\n  }\n\n  // the following methods can overwritten with class inheritance\n  // but should override version should call super.methodName()\n  protected onConnect() {\n    this.connected = true\n    this.options.onConnect?.()\n  }\n  protected onError(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.options.onError?.(err, eventOrData)\n  }\n  protected onClose(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.connected = false\n    this.options.onClose?.(err, eventOrData)\n  }\n\n  // base methods (should mostly not be overwritten)\n  protected setOptionalRequestTimeout<TRequest = any, TSchema = any>({\n    requestMessage,\n    timeout,\n    onTimeout,\n  }: {\n    requestMessage: Message<TRequest, TSchema>\n    timeout: number | undefined\n    onTimeout: OnTimeoutHandler<string, TRequest>\n  }) {\n    let reason: string\n    let timeoutMs: number | undefined\n\n    if (timeout !== undefined) {\n      reason =\n        this.options.timeoutFromRequestOptionsMessage?.(timeout) ??\n        `timeout after ${timeout}`\n      timeoutMs = timeout\n    } else if (this.options.timeout !== undefined) {\n      reason =\n        this.options.timeoutFromBridgeOptionsMessage?.(this.options.timeout) ??\n        `timeout after ${this.options.timeout}`\n      timeoutMs = this.options.timeout\n    }\n\n    if (timeoutMs === undefined) {\n      return\n    }\n    return setTimeout(() => {\n      requestMessage.timedOut = true\n      const opt: RequestMaybeNoError<string, TRequest> = {\n        reason,\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n      }\n      onTimeout(opt)\n    }, timeoutMs)\n  }\n\n  sendMessageTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        // check cancel\n        const cancelPromiseValue = {\n          request: opt.requestMessage.payload,\n          requestMessage: opt.requestMessage,\n          cancelled: true,\n          //responseMessage: undefined\n          //response: undefined,\n        } as RequestResponse<TRequest, TResponse, TError>\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<RequestResponse<TRequest, TResponse, TError>>(\n      (resolve, reject) => {\n        this.sendMessagePromiseHandler({\n          ...opt,\n          handleSuccess: (cancelled, response) => {\n            resolve(response)\n          },\n          handleError: (cancelled, response) => {\n            if (this.options.throwOnTrackedError) {\n              reject(response)\n            } else {\n              resolve(response)\n            }\n          },\n        })\n      },\n    ).finally(() => {\n      delete this.trackedRequestMap[opt.requestMessage.trackId]\n    })\n  }\n\n  /**\n   * Only resolve the promise with the TResponse (not the tracked/full response)\n   * onSuccess contains the response in the first argument (and the the tracked/full response in the second argument)\n   */\n  sendMessage<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    // check cancel\n    const cancelPromiseValue = undefined as TResponse\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<TResponse>((resolve, reject) => {\n      this.sendMessagePromiseHandler({\n        ...opt,\n        handleSuccess: (cancelled, response) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n            return\n          }\n          resolve(response.response)\n        },\n        handleError: (cancelled, response, error) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n          }\n          if (this.options.avoidThrowOnNonTrackedError) {\n            //@ts-ignore (The response is not the correct type, but we ignore it)\n            resolve(error?.payload)\n          } else {\n            reject(response)\n          }\n        },\n      })\n    })\n  }\n\n  protected sendMessagePromiseHandler<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >({\n    handleError,\n    handleSuccess,\n    requestMessage,\n    requestOptions,\n  }: SendMessageOptions<TRequest, TResponse, TError, TSchema> & {\n    handleError: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n      error?: RequestMaybeNoError<any, TRequest>,\n    ) => void\n    handleSuccess: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n    ) => void\n  }) {\n    requestMessage.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      requestMessage = this.options.interceptSendMessage(requestMessage)\n    }\n\n    // handle error and timeout\n    const handleErrorMessage = (\n      cancelled: boolean,\n      errOpt: RequestMaybeNoError<any, TRequest>,\n    ) => {\n      if (optionalTimeId) {\n        clearTimeout(optionalTimeId)\n      }\n\n      // resolve with error\n      const resolveWithError: RequestResponse<TRequest, TResponse, TError> = {\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        response: undefined,\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n        isError: true,\n        error: errOpt.reason,\n        errorMessage: errOpt.responseMessage,\n        cancelled:\n          requestMessage.cancelled ||\n          errOpt.requestMessage?.cancelled ||\n          errOpt.responseMessage?.cancelled,\n        timedOut:\n          requestMessage.timedOut ||\n          errOpt.requestMessage?.timedOut ||\n          errOpt.responseMessage?.timedOut,\n      }\n      if (\n        !cancelled ||\n        !this.options.callOnErrorWhenRequestIsCancelled ||\n        !requestOptions.callOnErrorWhenRequestIsCancelled\n      ) {\n        this.onError(resolveWithError)\n        requestOptions.onError?.(resolveWithError)\n      }\n      handleError(cancelled, resolveWithError, errOpt)\n    }\n    // set timeout if needed\n    const optionalTimeId = this.setOptionalRequestTimeout({\n      requestMessage,\n      timeout: requestOptions.timeout,\n      onTimeout: (timeoutErrorMessage) => {\n        const cancelled = this.handleCancelOptions(requestOptions, requestMessage)\n        handleErrorMessage(cancelled, timeoutErrorMessage)\n      },\n    })\n    // add to subscribedTrackIdMap\n    const track: InternalTrackedRequest<TRequest, TResponse, TError> = {\n      successTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestResponse<TRequest, TResponse, TError> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          response: response as TResponse,\n          responseMessage,\n          requestOptions,\n          request: requestMessage.payload,\n          requestMessage,\n          isError: false,\n          cancelled: requestMessage.cancelled || responseMessage.cancelled,\n          timedOut: requestMessage.timedOut || responseMessage.timedOut,\n        }\n        if (optionalTimeId) {\n          clearTimeout(optionalTimeId)\n        }\n\n        if (\n          !cancelled ||\n          !!this.options.callOnSuccessWhenRequestIsCancelled ||\n          !!requestOptions.callOnSuccessWhenRequestIsCancelled\n        ) {\n          this.options.onSuccess?.(opt)\n          requestOptions.onSuccess?.(opt)\n        }\n        handleSuccess(cancelled, opt)\n      },\n      errorTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestMaybeNoError<TError, TRequest> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          reason: response as TError,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n        }\n        handleErrorMessage(cancelled, opt)\n      },\n      requestMessage: requestMessage,\n      requestOptions,\n    }\n    this.trackedRequestMap[requestMessage.trackId] = track\n\n    // send message\n    this.internalSendMessage(requestMessage)\n  }\n\n  private handleCancelOptions<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    let resolveCancel = false\n    if (requestOptions.resolveCancelledForNonTracked !== undefined) {\n      resolveCancel = requestOptions.resolveCancelledForNonTracked\n    } else if (this.options.resolveCancelledNonTrackedRequest) {\n      resolveCancel = true\n    }\n    let cancelled = false\n    if (responseMessage?.cancelled || requestMessage.cancelled) {\n      cancelled = true\n    }\n    if (resolveCancel && cancelled) {\n      cancelled = false\n    }\n    return cancelled\n  }\n\n  private handleCancelResponse<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    const cancelled = this.handleCancelOptions(\n      requestOptions,\n      requestMessage,\n      responseMessage,\n    )\n    let response = responseMessage?.payload\n    if (cancelled) {\n      if (requestOptions.allowResponseValueWhenCancelled !== undefined) {\n        if (requestOptions.allowResponseValueWhenCancelled !== true) {\n          response = undefined as TResponse\n        }\n      } else if (this.options.allowResponseValueWhenCancelled !== true) {\n        response = undefined as TResponse\n      }\n    }\n    return { response, cancelled }\n  }\n\n  subscribeEvent<TResponse = any>({\n    name,\n    onEvent,\n  }: {\n    name: string | string[]\n    onEvent: SubscribeEvent<TResponse>\n  }): () => void {\n    if (Array.isArray(name)) {\n      const unsubs = name.map((_name) => this.subscribeEvent({ name: _name, onEvent }))\n      return () => unsubs.forEach((unsub) => unsub())\n    }\n    if (!this.subscribedEventListMap[name]) this.subscribedEventListMap[name] = []\n    this.subscribedEventListMap[name].push(onEvent)\n    return () => {\n      const index = this.subscribedEventListMap[name].findIndex((x) => x === onEvent)\n      this.subscribedEventListMap[name].splice(index, 1)\n    }\n  }\n\n  private createTrackedMessage<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    sendOptions: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const trackId = sendOptions.requestMessage.trackId\n    let createdMessage: CreatedMessage = {\n      trackId: trackId,\n      requestMessage: sendOptions.requestMessage,\n      requestOptions: sendOptions.requestOptions,\n      send: () => this.sendMessage(sendOptions),\n      sendTracked: () => this.sendMessageTracked(sendOptions),\n      cancel: () => {\n        // before run\n        if (sendOptions?.requestMessage) {\n          sendOptions.requestMessage.cancelled = true\n        }\n        // running\n        this.cancelRequest(trackId)\n      },\n    }\n    if (this.options.interceptCreatedMessageOptions) {\n      createdMessage = this.options.interceptCreatedMessageOptions(createdMessage)\n    }\n    return createdMessage\n  }\n\n  createCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createCommandMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  createQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createQueryMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  sendCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendCommandTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  sendQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendQueryTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  createEvent<TPayload = any>(\n    eventOptions: EventOptions<TPayload>,\n  ): CreatedEvent<TPayload> {\n    let eventMessage = createEventMessage<TPayload>(eventOptions)\n    eventMessage.direction = MessageDirection.ToServer\n    let createdEvent: CreatedEvent = {\n      trackId: eventMessage.trackId,\n      requestMessage: eventMessage,\n      requestOptions: eventOptions,\n      cancel: () => {\n        // before run\n        if (eventMessage) {\n          eventMessage.cancelled = true\n        }\n      },\n      send: () => {\n        if (eventMessage.cancelled) {\n          if (eventOptions.sendCancelled !== undefined) {\n            if (!eventOptions.sendCancelled) {\n              return\n            }\n          } else if (!this.options.sendCancelledRequest) {\n            return\n          }\n        }\n        if (this.options.interceptSendMessage) {\n          eventMessage = this.options.interceptSendMessage(eventMessage)\n        }\n        this.internalSendMessage(eventMessage)\n      },\n    }\n    if (this.options.interceptCreatedEventMessageOptions) {\n      createdEvent = this.options.interceptCreatedEventMessageOptions(createdEvent)\n    }\n\n    return createdEvent\n  }\n\n  sendEvent<TPayload = any>(\n    eventOptions: OmitAndOptional<\n      Message<TPayload>,\n      \"trackId\" | \"created\" | \"isError\" | \"type\",\n      \"direction\"\n    >,\n  ) {\n    return this.createEvent<TPayload>(eventOptions).send()\n  }\n\n  protected onMessage(messageString: string | Message) {\n    //console.log(\"onMessage\", messageString)\n    let messageDto: Message\n    try {\n      messageDto =\n        typeof messageString === \"string\"\n          ? (JSON.parse(messageString) as Message)\n          : messageString\n    } catch (e) {\n      this.onError(e as Error)\n      //console.log(\"Incorrect message received: \" + messageString)\n      return\n    }\n    try {\n      let msg = createMessageFromDto(messageDto)\n      if (this.options.interceptReceivedMessage) {\n        msg = this.options.interceptReceivedMessage(msg)\n      }\n      this.handleIncomingMessage(msg)\n    } catch (e) {\n      this.onError(e as Error)\n      if (this.options.logger && this.options.logParseIncomingMessageError) {\n        const logData = this.options.logParseIncomingMessageErrorFormat?.(messageDto) ?? [\n          e,\n        ]\n        this.options.logger(logData)\n      }\n    }\n  }\n\n  protected internalSendMessage(msg: Message) {\n    if (this.options.keepHistoryForSendingMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logSendingMessage) {\n      let log = true\n      if (this.options.logSendingMessageFilter) {\n        log = !!msg.name.match(this.options.logSendingMessageFilter)\n      }\n      if (log) {\n        const logData = this.options.logSendingMessageFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onSend?.(msg)\n    this.sendNetworkMessage(msg)\n  }\n\n  protected handleIncomingMessage(msg: Message) {\n    //console.log(\"handleIncomingMessage\", msg)\n    if (this.options.keepHistoryForReceivedMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logMessageReceived) {\n      let log = true\n      if (this.options.logMessageReceivedFilter) {\n        log = !!msg.name.match(this.options.logMessageReceivedFilter)\n      }\n      if (log) {\n        const logData = this.options.logMessageReceivedFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onMessage?.(msg)\n\n    let errorHandled = msg.type !== MessageType.Error\n\n    if (msg.type === MessageType.Event) {\n      this.receiveEventMessage(msg)\n      return\n    }\n    const trackMsg = this.trackedRequestMap[msg.trackId]\n    if (trackMsg) {\n      if (msg.type === MessageType.Error) {\n        trackMsg.errorTrack(msg)\n        errorHandled = true\n      } else {\n        trackMsg.successTrack(msg)\n      }\n      delete this.trackedRequestMap[msg.trackId]\n    }\n\n    if (!errorHandled) {\n      this.onError?.(msg)\n    }\n  }\n\n  protected receiveEventMessage(eventMsg: Message) {\n    if (this.subscribedEventListMap[eventMsg.name]) {\n      this.subscribedEventListMap[eventMsg.name].forEach((callback) =>\n        callback(eventMsg.payload, eventMsg),\n      )\n    }\n  }\n}\n","import { HubConnectionBuilder } from \"@microsoft/signalr\"\nimport { IHttpConnectionOptions } from \"@microsoft/signalr/src/IHttpConnectionOptions\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class SignalRMessageBridgeService extends MessageBridgeServiceBase {\n  connection?: signalR.HubConnection\n  connect(options: IHttpConnectionOptions = {}): Promise<void> {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.wsUri, options)\n      .withAutomaticReconnect()\n      .build()\n    if (!this.connection) {\n      throw new Error(\"Failed to create SignalR connection\")\n    }\n    this.connection.on(\"ReceiveMessage\", (messageString: string | Message) => {\n      this.onMessage(messageString)\n    })\n    this.connection.onclose((error) => {\n      this.onClose(error)\n    })\n    return this.connection\n      .start()\n      .then(() => {\n        this.onConnect()\n      })\n      .catch((err: Error) => {\n        this.onError(err)\n      })\n  }\n\n  close() {\n    this.connection?.stop()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.connection?.invoke(\"SendMessage\", msgJson).catch((err) => {\n      this.onError(err as Error)\n      return console.error(err.toString())\n    })\n  }\n}\n","import { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class WebsocketMessageBridgeService extends MessageBridgeServiceBase {\n  socket?: WebSocket\n  connectedCallback?: () => void\n\n  connect() {\n    this.socket = new WebSocket(this.wsUri)\n    this.socket.addEventListener(\"message\", (event) => {\n      const messageString: string | Message = event.data\n      this.onMessage(messageString)\n    })\n    this.socket.addEventListener(\"close\", (event) => {\n      this.onClose(event.reason, event)\n    })\n    this.socket.addEventListener(\"error\", (event) => {\n      this.onError(event, event)\n    })\n\n    return new Promise<void>((resolve, reject) => {\n      // Connection opened\n      this.socket?.addEventListener(\"open\", (event) => {\n        this.onConnect()\n        resolve()\n      })\n    })\n  }\n  close(): void {\n    this.socket?.close()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.socket?.send(msgJson)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\n\nexport type MessageBridgeClientServer = {\n  onMessage: (msg: Message) => void\n  connect: (sendMessage: (msg: Message) => void) => void\n}\n\nexport class ClientSideMessageBridgeService extends MessageBridgeServiceBase {\n  server?: MessageBridgeClientServer\n  setServer(server: MessageBridgeClientServer) {\n    this.server = server\n  }\n  connect() {\n    if (!this.server) {\n      throw new Error(\"No server set\")\n    }\n    this.server?.connect((msg) => {\n      // ensure that no object reference is passed to the client\n      const msgDetachRef = JSON.parse(JSON.stringify(msg))\n      this.onMessage(msgDetachRef)\n      this.onConnect()\n    })\n    return Promise.resolve()\n  }\n  close() {\n    this.onClose()\n  }\n  sendNetworkMessage(msg: Message) {\n    // ensure that no object reference is passed to the server\n    const msgDetachRef = JSON.parse(JSON.stringify(msg))\n    setTimeout(() => {\n      this.server?.onMessage(msgDetachRef)\n    }, 10)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\nimport { MessageBridgeClientServer } from \"./ClientSideMessageBridgeService\"\n\nexport type RequestErrorResponse = {\n  message: string\n  request?: Message | string\n  stack?: string\n  error?: unknown\n}\n\nexport type RequestHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any, cancelled?: boolean, timedOut?: boolean) => void\n  response: (response: TResponse) => void\n  sendResponseMessage: (responseMessage: Message<TRequest, TResponse>) => void\n  createResponseMessage(response: TResponse): Message<TRequest, TResponse>\n}) => void\n\nexport type RequestEventHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n}) => void\n\nexport class InMemoryClientSideServer<TStore> implements MessageBridgeClientServer {\n  store = {} as TStore\n  commands = {} as { [name: string]: RequestHandler }\n  queries = {} as { [name: string]: RequestHandler }\n  eventListeners = {} as { [name: string]: RequestEventHandler }\n\n  saveToLocalStorage(key: string) {\n    localStorage.setItem(key, JSON.stringify(this.store))\n  }\n  loadFromLocalStorage(key: string) {\n    const store = localStorage.getItem(key)\n    if (store) {\n      this.store = JSON.parse(store) as TStore\n    }\n  }\n\n  sendMessage?: (msg: Message<RequestErrorResponse>) => void\n\n  connect(sendMessage: (msg: Message) => void) {\n    this.sendMessage = sendMessage\n  }\n\n  sendError(\n    payload: RequestErrorResponse,\n    trackId?: string,\n    cancelled?: boolean,\n    timedOut?: boolean,\n  ) {\n    const errorMsg = createMessage({\n      trackId,\n      type: MessageType.Error,\n      name: \"Error\",\n      payload: payload,\n      direction: MessageDirection.ToClient,\n      cancelled,\n      timedOut,\n    })\n    //console.log(\"SERVER: sendError\", errorMsg)\n    this.sendMessage?.(errorMsg)\n  }\n\n  createMessage(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = createMessage({\n      ...opt,\n      direction: MessageDirection.ToClient,\n    })\n    return responseMessage\n  }\n\n  sendResponse(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = this.createMessage(opt)\n    //console.log(\"SERVER: sendResponse\", responseMessage)\n    this.sendMessage?.(responseMessage)\n  }\n\n  sendEvent(name: string, payload: any) {\n    const responseMessage = createMessage({\n      type: MessageType.Event,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    this.sendMessage?.(responseMessage)\n  }\n\n  onMessage(requestMessage: Message | string) {\n    //console.log(\"SERVER: onMessage\", requestMessage)\n    if (typeof requestMessage === \"string\") {\n      try {\n        requestMessage = JSON.parse(requestMessage) as Message\n      } catch (e) {\n        this.sendError({\n          message: `Error parsing message: ${e}`,\n          request: requestMessage,\n          error: e,\n          stack: (e as any)?.stack,\n        })\n        console.error(\"Error parsing message\", e)\n        return\n      }\n    }\n    if (requestMessage.type === \"Command\") {\n      if (!this.commands[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Command ${requestMessage.name} not found (Register it with addCommand)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleCommand(requestMessage)\n    }\n    if (requestMessage.type === \"Query\") {\n      if (!this.queries[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Query ${requestMessage.name} not found (Register it with addQuery)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleQuery(requestMessage)\n    }\n    if (requestMessage.type === \"Event\") {\n      if (!this.eventListeners[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Event ${requestMessage.name} not found (Register it with addEvent)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleEvent(requestMessage)\n    }\n  }\n  serverHandleCommand(requestMessage: Message) {\n    const handler = this.commands[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.CommandResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    try {\n      handler({\n        requestMessage: requestMessage,\n        request: requestMessage.payload,\n        store: this.store,\n        error: sendError,\n        event: fireEvent,\n        response: sendResponse,\n        createResponseMessage,\n        sendResponseMessage,\n      })\n    } catch (e) {\n      sendError({\n        message: `Error in command handler for '${requestMessage.name}'`,\n        requestMessage: requestMessage,\n        error: e,\n        stack: (e as any)?.stack,\n      })\n    }\n  }\n\n  serverHandleQuery(requestMessage: Message) {\n    const handler = this.queries[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.QueryResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n      response: sendResponse,\n      createResponseMessage,\n      sendResponseMessage,\n    })\n  }\n  serverHandleEvent(requestMessage: Message) {\n    const handler = this.eventListeners[requestMessage.name]\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n    })\n  }\n  // In memory message bridge service\n  addCommand<TCommand = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TCommand, TResponse, TStore>,\n  ) {\n    this.commands[name] = handler\n  }\n  addQuery<TQuery = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TQuery, TResponse, TStore>,\n  ) {\n    this.queries[name] = handler\n  }\n  addEventListener<TEvent = any>(\n    name: string,\n    handler: RequestEventHandler<TEvent, void, TStore>,\n  ) {\n    this.eventListeners[name] = handler\n  }\n}\n"],"names":["MessageType","createMessageFromDto","msg","direction","MessageDirection","ToClient","isError","type","Error","opt","_opt$direction","_opt$trackId","name","payload","trackId","v4","module","schema","created","toISOString","createCommandMessage","createMessage","_extends","Command","Query","createEventMessage","Event","MessageBridgeServiceBase","constructor","wsUri","connected","this","trackedRequestMap","subscribedEventListMap","history","bridgeErrors","options","timeout","undefined","allowResponseValueWhenCancelled","keepHistoryForReceivedMessages","keepHistoryForSendingMessages","logger","data","_console$log","_console","console","log","logParseIncomingMessageError","timeoutFromBridgeOptionsMessage","ms","timeoutFromRequestOptionsMessage","logParseIncomingMessageErrorFormat","err","logMessageReceived","logMessageReceivedFormat","logSendingMessage","logSendingMessageFormat","setOptions","getTrackedRequestMessage","_this$trackedRequestM","requestMessage","cancelRequest","cancelled","onConnect","_this$options$onConne","_this$options","call","onError","eventOrData","_this$options$onError","_this$options2","push","onClose","_this$options$onClose","_this$options3","setOptionalRequestTimeout","onTimeout","reason","timeoutMs","_this$options$timeout","_this$options$timeout2","_this$options4","_this$options$timeout3","_this$options$timeout4","_this$options5","setTimeout","timedOut","responseMessage","request","sendMessageTracked","cancel","requestOptions","sendCancelled","sendCancelledRequest","Promise","resolve","reject","sendMessagePromiseHandler","handleSuccess","response","handleError","throwOnTrackedError","finally","sendMessage","cancelPromiseValue","error","avoidThrowOnNonTrackedError","ToServer","interceptSendMessage","handleErrorMessage","errOpt","_errOpt$requestMessag","_errOpt$responseMessa","_errOpt$requestMessag2","_errOpt$responseMessa2","optionalTimeId","clearTimeout","resolveWithError","errorMessage","callOnErrorWhenRequestIsCancelled","timeoutErrorMessage","handleCancelOptions","successTrack","handleCancelResponse","_this$options$onSucce","_this$options6","callOnSuccessWhenRequestIsCancelled","onSuccess","errorTrack","internalSendMessage","resolveCancel","resolveCancelledForNonTracked","resolveCancelledNonTrackedRequest","subscribeEvent","onEvent","Array","isArray","unsubs","map","_name","forEach","unsub","index","findIndex","x","splice","createTrackedMessage","sendOptions","createdMessage","send","sendTracked","interceptCreatedMessageOptions","createCommand","createQuery","createQueryMessage","sendCommand","sendCommandTracked","sendQuery","sendQueryTracked","createEvent","eventOptions","eventMessage","createdEvent","interceptCreatedEventMessageOptions","sendEvent","onMessage","messageString","messageDto","JSON","parse","e","interceptReceivedMessage","handleIncomingMessage","_this$options$logPars","_this$options$logPars2","_this$options7","logData","_this$options$onSend","_this$options9","logSendingMessageFilter","match","_this$options$logSend","_this$options$logSend2","_this$options8","onSend","sendNetworkMessage","_this$options$onMessa","_this$options11","logMessageReceivedFilter","_this$options$logMess","_this$options$logMess2","_this$options10","errorHandled","receiveEventMessage","trackMsg","_this$onError","eventMsg","callback","connection","connect","withUrl","withAutomaticReconnect","build","on","onclose","start","then","catch","close","_this$connection","stop","_this$connection2","msgJson","stringify","invoke","toString","WebsocketMessageBridgeService","socket","connectedCallback","WebSocket","addEventListener","event","_this$socket","_this$socket2","_this$socket3","ClientSideMessageBridgeService","server","setServer","_this$server","msgDetachRef","_this$server2","InMemoryClientSideServer","store","commands","queries","eventListeners","saveToLocalStorage","key","localStorage","setItem","loadFromLocalStorage","getItem","sendError","_this$sendMessage","errorMsg","sendResponse","_this$sendMessage2","_this$sendMessage3","message","stack","serverHandleCommand","serverHandleQuery","serverHandleEvent","handler","sendResponseMessage","_this$sendMessage4","createResponseMessage","CommandResponse","fireEvent","QueryResponse","addCommand","addQuery"],"mappings":"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"}