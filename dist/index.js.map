{"version":3,"file":"index.js","sources":["../src/MessageBridgeTypes.ts","../src/MessageBridgeHelper.ts","../src/MessageBridgeServiceBase.ts","../src/services/ClientSideMessageBridgeService.ts","../src/services/InMemoryClientSideServer.ts","../src/services/SignalRMessageBridgeService.ts","../src/services/WebsocketMessageBridgeService.ts"],"sourcesContent":["// Typescript util\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type OmitAndOptional<\n  T,\n  TOmit extends keyof T,\n  TOpt extends keyof Omit<T, TOmit>,\n> = Pick<Partial<Omit<T, TOmit>>, TOpt> & Omit<Omit<T, TOmit>, TOpt>\n\n// bridge\nexport type BridgeOptions = {\n  // Add listeners:\n  onMessage?: (msg: Message) => void\n  onSend?: (msg: Message) => void\n  onError?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onSuccess?: (msg: RequestResponse) => void\n  onClose?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onConnect?: () => void\n  // Can be used to send a cancel request to the server\n  onCancel?: (msg: Message) => void\n  // Interception:\n  // - can be used to generalize behavior (Happens as early as possible in the process)\n  // Happens just after user options is applied. Before stored in track map and before any other actions.\n  interceptSendMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after message-string parsing, but before stored in history, onMessage and all other actions\n  // To get request for the message use: getTrackedRequestMessage(trackId: string): Message | undefined\n  interceptReceivedMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after the options for createMessage is applied)\n  interceptCreatedMessageOptions?: (msg: CreatedMessage) => CreatedMessage // (default: undefined)\n  interceptCreatedEventMessageOptions?: (msg: CreatedEvent) => CreatedEvent // (default: undefined)\n  // Handle errors and timeouts:\n  avoidThrowOnNonTrackedError?: boolean // (default: undefined)\n  throwOnTrackedError?: boolean // (default: undefined)\n  timeout?: number // (default: undefined)\n  // Cancel\n  // resolve on cancel (Let the process that did the request handle the cancel)\n  resolveCancelledNonTrackedRequest?: boolean // (default: undefined)\n  sendCancelledRequest?: boolean // (default: undefined)\n  callOnErrorWhenRequestIsCancelled?: boolean // (default: undefined)\n  callOnSuccessWhenRequestIsCancelled?: boolean // (default: undefined)\n  // if true, the response can still have a value, else it will be undefined\n  allowResponseValueWhenCancelled?: boolean // (default: undefined)\n  // Debugging options:\n  timeoutFromBridgeOptionsMessage?: (ms: number) => string // (has default implementation)\n  timeoutFromRequestOptionsMessage?: (ms: number) => string // (has default implementation)\n  keepHistoryForReceivedMessages?: boolean // (default: false)\n  keepHistoryForSendingMessages?: boolean // (default: false)\n  logger?: (...data: any[]) => void // set custom logger (default: console?.log)\n  logParseIncomingMessageError?: boolean // (default: true)\n  logParseIncomingMessageErrorFormat?: (err: unknown) => any[] // (has default implementation)\n  logMessageReceived?: boolean // log all messages received\n  logMessageReceivedFormat?: (msg: Message) => any[] // (has default implementation)\n  logSendingMessage?: boolean // log all messages sent\n  logSendingMessageFormat?: (msg: Message) => any[] // (has default implementation)\n  logMessageReceivedFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n  logSendingMessageFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n}\n// enums (These are runtime enums)\nexport enum MessageType {\n  Command = \"Command\",\n  CommandResponse = \"CommandResponse\",\n  Query = \"Query\",\n  QueryResponse = \"QueryResponse\",\n  Event = \"Event\",\n  Error = \"Error\",\n}\n\nexport enum MessageDirection {\n  ToClient = \"ToClient\",\n  ToServer = \"ToServer\",\n}\n\n// types (Not runtime)\nexport type Message<TPayload = any, TSchema = any> = {\n  module?: string\n  name: string\n  type: MessageType\n  isError: boolean\n  cancelled?: boolean\n  timedOut?: boolean\n  trackId: string\n  created: string\n  payload: TPayload\n  schema?: TSchema\n  direction: MessageDirection\n}\n\n// Request\nexport type RequestResponse<TRequest = any, TResponse = any, TError = any> = {\n  response: TResponse\n  request: TRequest\n  responseMessage: Message<TResponse>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  isError?: boolean\n  error?: TError\n  errorMessage?: Message<TError>\n  cancelled?: boolean\n  timedOut?: boolean\n}\n\nexport type RequestOptions<TRequest, TResponse, TError = any> = {\n  name: string\n  payload: TRequest\n  onSuccess?: TrackedOnSuccess<TRequest, TResponse>\n  onError?: TrackedOnError<TRequest, TResponse, TError>\n  module?: string\n  timeout?: number\n  resolveCancelledForNonTracked?: boolean\n  sendCancelled?: boolean\n  callOnErrorWhenRequestIsCancelled?: boolean\n  callOnSuccessWhenRequestIsCancelled?: boolean\n  allowResponseValueWhenCancelled?: boolean\n}\n\nexport type SendMessageOptions<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n\nexport type CreatedMessage<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  trackId: string\n  requestMessage: Message<TRequest, TSchema>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n  send: () => Promise<TResponse>\n  sendTracked: () => Promise<RequestResponse<TRequest, TResponse, TError>>\n  cancel: () => void\n}\n\nexport type CreatedEvent<TPayload = any> = {\n  trackId: string\n  requestMessage: Message<TPayload>\n  requestOptions: EventOptions<TPayload>\n  send: () => void\n  cancel: () => void\n}\n\nexport type EventOptions<TPayload = any> = {\n  name: string\n  payload: TPayload\n  module?: string\n  sendCancelled?: boolean\n}\n\nexport type TrackedOnSuccess<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => void\n\nexport type TrackedOnError<TRequest = any, TResponse = any, TError = any> = (\n  opt: RequestResponse<TRequest, TResponse, TError>,\n) => void\n\nexport type SubscribeEvent<TResponse> = (\n  payload: TResponse,\n  eventMessage: Message<TResponse>,\n) => void\n\n// Error\nexport type RequestMaybeNoError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type OnTimeoutHandler<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => void\n\n// Internal Tracked\n// used by tracking (No return value '=> void', it uses promise 'resolve')\nexport type InternalTrackedOnSuccess<TResponse> = (\n  responseMessage: Message<TResponse>,\n) => void\n\nexport type InternalTrackedOnError<TError> = (\n  responseMessage: Message<TError> | undefined,\n) => void\n\nexport type InternalTrackedRequest<TRequest, TResponse, TError = any> = {\n  successTrack: InternalTrackedOnSuccess<TResponse>\n  errorTrack: InternalTrackedOnError<TError>\n  requestMessage: Message<TRequest>\n  requestOptions: RequestOptions<TRequest, TResponse, TError>\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  OmitAndOptional,\n} from \"./MessageBridgeTypes\"\nimport { v4 } from \"uuid\"\n\nexport function createMessageFromDto<TPayload = any, TSchema = any>(\n  msg: Message<TPayload, TSchema>,\n  direction = MessageDirection.ToClient,\n): Message<TPayload, TSchema> {\n  msg.isError = msg.type === MessageType.Error\n  msg.direction ??= direction\n  return msg\n}\n\nexport function createMessage<TPayload = any | undefined, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TPayload, TSchema>,\n    \"created\" | \"isError\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TPayload, TSchema> {\n  return {\n    name: opt.name,\n    payload: opt.payload,\n    type: opt.type,\n    // optionals\n    direction: opt.direction ?? MessageDirection.ToClient,\n    trackId: opt.trackId ?? v4(),\n    module: opt.module,\n    schema: opt.schema,\n    // alway created\n    created: new Date().toISOString(),\n    isError: opt.type === MessageType.Error,\n  }\n}\n\nexport function createCommandMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TRequest, TSchema> {\n  return createMessage({\n    ...opt,\n    type: MessageType.Command,\n  })\n}\n\nexport function createQueryMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Query,\n  })\n}\n\nexport function createEventMessage<TPayload = any>(\n  opt: OmitAndOptional<\n    Message<TPayload>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage<TPayload>({\n    ...opt,\n    type: MessageType.Event,\n  })\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  RequestResponse,\n  SubscribeEvent,\n  InternalTrackedRequest,\n  OmitAndOptional,\n  OnTimeoutHandler,\n  RequestOptions,\n  BridgeOptions,\n  RequestMaybeNoError,\n  SendMessageOptions,\n  CreatedMessage,\n  CreatedEvent,\n  EventOptions,\n} from \"./MessageBridgeTypes\"\n\nimport {\n  createCommandMessage,\n  createEventMessage,\n  createMessageFromDto,\n  createQueryMessage,\n} from \"./MessageBridgeHelper\"\n\nexport abstract class MessageBridgeServiceBase {\n  connected = false\n  trackedRequestMap: {\n    [trackId: string]: InternalTrackedRequest<any, any>\n  } = {}\n\n  subscribedEventListMap: {\n    [eventName: string]: SubscribeEvent<any>[]\n  } = {}\n\n  history: Message[] = []\n  bridgeErrors: unknown[] /*Error*/ = []\n\n  options: BridgeOptions = {\n    timeout: undefined,\n    allowResponseValueWhenCancelled: false,\n    keepHistoryForReceivedMessages: false,\n    keepHistoryForSendingMessages: false,\n    logger: (...data: any[]) => console?.log ?? (() => {}),\n    logParseIncomingMessageError: true,\n    timeoutFromBridgeOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (BridgeOptions.timeout)`,\n    timeoutFromRequestOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (RequestOptions.timeout)`,\n    logParseIncomingMessageErrorFormat: (err: unknown) => [\n      \"Bridge-Error (parse messageReceived):\",\n      err,\n    ],\n    logMessageReceived: false,\n    logMessageReceivedFormat: (msg: Message) => [\"Bridge (messageReceived):\", msg],\n    logSendingMessage: false,\n    logSendingMessageFormat: (msg: Message) => [\"Bridge (sendingMessage):\", msg],\n  }\n\n  constructor(public wsUri: string) {}\n\n  abstract connect(options?: unknown): Promise<void>\n  abstract close(): void\n  abstract sendNetworkMessage(msg: Message): void\n\n  setOptions(opt: BridgeOptions) {\n    this.options = { ...this.options, ...opt }\n  }\n\n  getTrackedRequestMessage(trackId: string): Message | undefined {\n    return this.trackedRequestMap[trackId]?.requestMessage\n  }\n\n  // This will not cancel the request itself (on the server),\n  // but set a cancel flag on the trackMap (so the response will be ignored)\n  cancelRequest(trackId: string): void {\n    if (this.trackedRequestMap[trackId]) {\n      this.trackedRequestMap[trackId].requestMessage.cancelled = true\n    }\n  }\n\n  // the following methods can overwritten with class inheritance\n  // but should override version should call super.methodName()\n  protected onConnect() {\n    this.connected = true\n    this.options.onConnect?.()\n  }\n  protected onError(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.options.onError?.(err, eventOrData)\n  }\n  protected onClose(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.connected = false\n    this.options.onClose?.(err, eventOrData)\n  }\n\n  // base methods (should mostly not be overwritten)\n  protected setOptionalRequestTimeout<TRequest = any, TSchema = any>({\n    requestMessage,\n    timeout,\n    onTimeout,\n  }: {\n    requestMessage: Message<TRequest, TSchema>\n    timeout: number | undefined\n    onTimeout: OnTimeoutHandler<string, TRequest>\n  }) {\n    let reason: string\n    let timeoutMs: number | undefined\n\n    if (timeout !== undefined) {\n      reason =\n        this.options.timeoutFromRequestOptionsMessage?.(timeout) ??\n        `timeout after ${timeout}`\n      timeoutMs = timeout\n    } else if (this.options.timeout !== undefined) {\n      reason =\n        this.options.timeoutFromBridgeOptionsMessage?.(this.options.timeout) ??\n        `timeout after ${this.options.timeout}`\n      timeoutMs = this.options.timeout\n    }\n\n    if (timeoutMs === undefined) {\n      return\n    }\n    return setTimeout(() => {\n      requestMessage.timedOut = true\n      const opt: RequestMaybeNoError<string, TRequest> = {\n        reason,\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n      }\n      onTimeout(opt)\n    }, timeoutMs)\n  }\n\n  sendMessageTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        // check cancel\n        const cancelPromiseValue = {\n          request: opt.requestMessage.payload,\n          requestMessage: opt.requestMessage,\n          cancelled: true,\n          //responseMessage: undefined\n          //response: undefined,\n        } as RequestResponse<TRequest, TResponse, TError>\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<RequestResponse<TRequest, TResponse, TError>>(\n      (resolve, reject) => {\n        this.sendMessagePromiseHandler({\n          ...opt,\n          handleSuccess: (cancelled, response) => {\n            resolve(response)\n          },\n          handleError: (cancelled, response) => {\n            if (this.options.throwOnTrackedError) {\n              reject(response)\n            } else {\n              resolve(response)\n            }\n          },\n        })\n      },\n    ).finally(() => {\n      delete this.trackedRequestMap[opt.requestMessage.trackId]\n    })\n  }\n\n  /**\n   * Only resolve the promise with the TResponse (not the tracked/full response)\n   * onSuccess contains the response in the first argument (and the the tracked/full response in the second argument)\n   */\n  sendMessage<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    // check cancel\n    const cancelPromiseValue = undefined as TResponse\n    if (opt.requestMessage.cancelled) {\n      let cancel = true\n      if (opt.requestOptions.sendCancelled !== undefined) {\n        cancel = !opt.requestOptions.sendCancelled\n      } else if (this.options.sendCancelledRequest) {\n        cancel = false\n      }\n      if (cancel) {\n        return Promise.resolve(cancelPromiseValue)\n      }\n    }\n    return new Promise<TResponse>((resolve, reject) => {\n      this.sendMessagePromiseHandler({\n        ...opt,\n        handleSuccess: (cancelled, response) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n            return\n          }\n          resolve(response.response)\n        },\n        handleError: (cancelled, response, error) => {\n          if (cancelled) {\n            resolve(cancelPromiseValue)\n          }\n          if (this.options.avoidThrowOnNonTrackedError) {\n            //@ts-ignore (The response is not the correct type, but we ignore it)\n            resolve(error?.payload)\n          } else {\n            reject(response)\n          }\n        },\n      })\n    })\n  }\n\n  protected sendMessagePromiseHandler<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >({\n    handleError,\n    handleSuccess,\n    requestMessage,\n    requestOptions,\n  }: SendMessageOptions<TRequest, TResponse, TError, TSchema> & {\n    handleError: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n      error?: RequestMaybeNoError<any, TRequest>,\n    ) => void\n    handleSuccess: (\n      cancelled: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n    ) => void\n  }) {\n    requestMessage.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      requestMessage = this.options.interceptSendMessage(requestMessage)\n    }\n\n    // handle error and timeout\n    const handleErrorMessage = (\n      cancelled: boolean,\n      errOpt: RequestMaybeNoError<any, TRequest>,\n    ) => {\n      if (optionalTimeId) {\n        clearTimeout(optionalTimeId)\n      }\n\n      // resolve with error\n      const resolveWithError: RequestResponse<TRequest, TResponse, TError> = {\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        response: undefined,\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n        isError: true,\n        error: errOpt.reason,\n        errorMessage: errOpt.responseMessage,\n        cancelled:\n          requestMessage.cancelled ||\n          errOpt.requestMessage?.cancelled ||\n          errOpt.responseMessage?.cancelled,\n        timedOut:\n          requestMessage.timedOut ||\n          errOpt.requestMessage?.timedOut ||\n          errOpt.responseMessage?.timedOut,\n      }\n      if (\n        !cancelled ||\n        !this.options.callOnErrorWhenRequestIsCancelled ||\n        !requestOptions.callOnErrorWhenRequestIsCancelled\n      ) {\n        this.onError(resolveWithError)\n        requestOptions.onError?.(resolveWithError)\n      }\n      handleError(cancelled, resolveWithError, errOpt)\n    }\n    // set timeout if needed\n    const optionalTimeId = this.setOptionalRequestTimeout({\n      requestMessage,\n      timeout: requestOptions.timeout,\n      onTimeout: (timeoutErrorMessage) => {\n        const cancelled = this.handleCancelOptions(requestOptions, requestMessage)\n        handleErrorMessage(cancelled, timeoutErrorMessage)\n      },\n    })\n    // add to subscribedTrackIdMap\n    const track: InternalTrackedRequest<TRequest, TResponse, TError> = {\n      successTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestResponse<TRequest, TResponse, TError> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          response: response as TResponse,\n          responseMessage,\n          requestOptions,\n          request: requestMessage.payload,\n          requestMessage,\n          isError: false,\n          cancelled: requestMessage.cancelled || responseMessage.cancelled,\n          timedOut: requestMessage.timedOut || responseMessage.timedOut,\n        }\n        if (optionalTimeId) {\n          clearTimeout(optionalTimeId)\n        }\n\n        if (\n          !cancelled ||\n          !!this.options.callOnSuccessWhenRequestIsCancelled ||\n          !!requestOptions.callOnSuccessWhenRequestIsCancelled\n        ) {\n          this.options.onSuccess?.(opt)\n          requestOptions.onSuccess?.(opt)\n        }\n        handleSuccess(cancelled, opt)\n      },\n      errorTrack: (responseMessage) => {\n        const { response, cancelled } = this.handleCancelResponse<\n          TRequest,\n          TResponse,\n          TError\n        >(requestOptions, requestMessage, responseMessage)\n\n        const opt: RequestMaybeNoError<TError, TRequest> = {\n          // 'response' be undefined if timedOut or response from server is undefined\n          // Or be forced undefined if cancelled (bridge or request options)\n          reason: response as TError,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n        }\n        handleErrorMessage(cancelled, opt)\n      },\n      requestMessage: requestMessage,\n      requestOptions,\n    }\n    this.trackedRequestMap[requestMessage.trackId] = track\n\n    // send message\n    this.internalSendMessage(requestMessage)\n  }\n\n  private handleCancelOptions<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    let resolveCancel = false\n    if (requestOptions.resolveCancelledForNonTracked !== undefined) {\n      resolveCancel = requestOptions.resolveCancelledForNonTracked\n    } else if (this.options.resolveCancelledNonTrackedRequest) {\n      resolveCancel = true\n    }\n    let cancelled = false\n    if (responseMessage?.cancelled || requestMessage.cancelled) {\n      cancelled = true\n    }\n    if (resolveCancel && cancelled) {\n      cancelled = false\n    }\n    return cancelled\n  }\n\n  private handleCancelResponse<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n    requestMessage: Message<TRequest, TSchema>,\n    responseMessage?: Message<TResponse | TError, any>,\n  ) {\n    const cancelled = this.handleCancelOptions(\n      requestOptions,\n      requestMessage,\n      responseMessage,\n    )\n    let response = responseMessage?.payload\n    if (cancelled) {\n      if (requestOptions.allowResponseValueWhenCancelled !== undefined) {\n        if (requestOptions.allowResponseValueWhenCancelled !== true) {\n          response = undefined as TResponse\n        }\n      } else if (this.options.allowResponseValueWhenCancelled !== true) {\n        response = undefined as TResponse\n      }\n    }\n    return { response, cancelled }\n  }\n\n  subscribeEvent<TResponse = any>({\n    name,\n    onEvent,\n  }: {\n    name: string | string[]\n    onEvent: SubscribeEvent<TResponse>\n  }): () => void {\n    if (Array.isArray(name)) {\n      const unsubs = name.map((_name) => this.subscribeEvent({ name: _name, onEvent }))\n      return () => unsubs.forEach((unsub) => unsub())\n    }\n    if (!this.subscribedEventListMap[name]) this.subscribedEventListMap[name] = []\n    this.subscribedEventListMap[name].push(onEvent)\n    return () => {\n      const index = this.subscribedEventListMap[name].findIndex((x) => x === onEvent)\n      this.subscribedEventListMap[name].splice(index, 1)\n    }\n  }\n\n  private createTrackedMessage<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >(\n    sendOptions: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const trackId = sendOptions.requestMessage.trackId\n    let createdMessage: CreatedMessage = {\n      trackId: trackId,\n      requestMessage: sendOptions.requestMessage,\n      requestOptions: sendOptions.requestOptions,\n      send: () => this.sendMessage(sendOptions),\n      sendTracked: () => this.sendMessageTracked(sendOptions),\n      cancel: () => {\n        // before run\n        if (sendOptions?.requestMessage) {\n          sendOptions.requestMessage.cancelled = true\n        }\n        // running\n        this.cancelRequest(trackId)\n      },\n    }\n    if (this.options.interceptCreatedMessageOptions) {\n      createdMessage = this.options.interceptCreatedMessageOptions(createdMessage)\n    }\n    return createdMessage\n  }\n\n  createCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createCommandMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  createQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ): CreatedMessage<TRequest, TResponse, TError, TSchema> {\n    const requestMessage = createQueryMessage(requestOptions)\n    return this.createTrackedMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage,\n      requestOptions,\n    })\n  }\n\n  sendCommand<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendCommandTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createCommand<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  sendQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(requestOptions).send()\n  }\n\n  sendQueryTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    requestOptions: RequestOptions<TRequest, TResponse, TError>,\n  ) {\n    return this.createQuery<TRequest, TResponse, TError, TSchema>(\n      requestOptions,\n    ).sendTracked()\n  }\n\n  createEvent<TPayload = any>(\n    eventOptions: EventOptions<TPayload>,\n  ): CreatedEvent<TPayload> {\n    let eventMessage = createEventMessage<TPayload>(eventOptions)\n    eventMessage.direction = MessageDirection.ToServer\n    let createdEvent: CreatedEvent = {\n      trackId: eventMessage.trackId,\n      requestMessage: eventMessage,\n      requestOptions: eventOptions,\n      cancel: () => {\n        // before run\n        if (eventMessage) {\n          eventMessage.cancelled = true\n        }\n      },\n      send: () => {\n        if (eventMessage.cancelled) {\n          if (eventOptions.sendCancelled !== undefined) {\n            if (!eventOptions.sendCancelled) {\n              return\n            }\n          } else if (!this.options.sendCancelledRequest) {\n            return\n          }\n        }\n        if (this.options.interceptSendMessage) {\n          eventMessage = this.options.interceptSendMessage(eventMessage)\n        }\n        this.internalSendMessage(eventMessage)\n      },\n    }\n    if (this.options.interceptCreatedEventMessageOptions) {\n      createdEvent = this.options.interceptCreatedEventMessageOptions(createdEvent)\n    }\n\n    return createdEvent\n  }\n\n  sendEvent<TPayload = any>(\n    eventOptions: OmitAndOptional<\n      Message<TPayload>,\n      \"trackId\" | \"created\" | \"isError\" | \"type\",\n      \"direction\"\n    >,\n  ) {\n    return this.createEvent<TPayload>(eventOptions).send()\n  }\n\n  protected onMessage(messageString: string | Message) {\n    //console.log(\"onMessage\", messageString)\n    let messageDto: Message\n    try {\n      messageDto =\n        typeof messageString === \"string\"\n          ? (JSON.parse(messageString) as Message)\n          : messageString\n    } catch (e) {\n      this.onError(e as Error)\n      //console.log(\"Incorrect message received: \" + messageString)\n      return\n    }\n    try {\n      let msg = createMessageFromDto(messageDto)\n      if (this.options.interceptReceivedMessage) {\n        msg = this.options.interceptReceivedMessage(msg)\n      }\n      this.handleIncomingMessage(msg)\n    } catch (e) {\n      this.onError(e as Error)\n      if (this.options.logger && this.options.logParseIncomingMessageError) {\n        const logData = this.options.logParseIncomingMessageErrorFormat?.(messageDto) ?? [\n          e,\n        ]\n        this.options.logger(logData)\n      }\n    }\n  }\n\n  protected internalSendMessage(msg: Message) {\n    if (this.options.keepHistoryForSendingMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logSendingMessage) {\n      let log = true\n      if (this.options.logSendingMessageFilter) {\n        log = !!msg.name.match(this.options.logSendingMessageFilter)\n      }\n      if (log) {\n        const logData = this.options.logSendingMessageFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onSend?.(msg)\n    this.sendNetworkMessage(msg)\n  }\n\n  protected handleIncomingMessage(msg: Message) {\n    //console.log(\"handleIncomingMessage\", msg)\n    if (this.options.keepHistoryForReceivedMessages) {\n      this.history.push(msg)\n    }\n    if (this.options.logger && this.options.logMessageReceived) {\n      let log = true\n      if (this.options.logMessageReceivedFilter) {\n        log = !!msg.name.match(this.options.logMessageReceivedFilter)\n      }\n      if (log) {\n        const logData = this.options.logMessageReceivedFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onMessage?.(msg)\n\n    let errorHandled = msg.type !== MessageType.Error\n\n    if (msg.type === MessageType.Event) {\n      this.receiveEventMessage(msg)\n      return\n    }\n    const trackMsg = this.trackedRequestMap[msg.trackId]\n    if (trackMsg) {\n      if (msg.type === MessageType.Error) {\n        trackMsg.errorTrack(msg)\n        errorHandled = true\n      } else {\n        trackMsg.successTrack(msg)\n      }\n      delete this.trackedRequestMap[msg.trackId]\n    }\n\n    if (!errorHandled) {\n      this.onError?.(msg)\n    }\n  }\n\n  protected receiveEventMessage(eventMsg: Message) {\n    if (this.subscribedEventListMap[eventMsg.name]) {\n      this.subscribedEventListMap[eventMsg.name].forEach((callback) =>\n        callback(eventMsg.payload, eventMsg),\n      )\n    }\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\n\nexport type MessageBridgeClientServer = {\n  onMessage: (msg: Message) => void\n  connect: (sendMessage: (msg: Message) => void) => void\n}\n\nexport class ClientSideMessageBridgeService extends MessageBridgeServiceBase {\n  server?: MessageBridgeClientServer\n  setServer(server: MessageBridgeClientServer) {\n    this.server = server\n  }\n  connect() {\n    if (!this.server) {\n      throw new Error(\"No server set\")\n    }\n    this.server?.connect((msg) => {\n      // ensure that no object reference is passed to the client\n      const msgDetachRef = JSON.parse(JSON.stringify(msg))\n      this.onMessage(msgDetachRef)\n      this.onConnect()\n    })\n    return Promise.resolve()\n  }\n  close() {\n    this.onClose()\n  }\n  sendNetworkMessage(msg: Message) {\n    // ensure that no object reference is passed to the server\n    const msgDetachRef = JSON.parse(JSON.stringify(msg))\n    setTimeout(() => {\n      this.server?.onMessage(msgDetachRef)\n    }, 10)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\nimport { MessageBridgeClientServer } from \"./ClientSideMessageBridgeService\"\n\nexport type RequestErrorResponse = {\n  message: string\n  request?: Message | string\n  stack?: string\n  error?: unknown\n}\n\nexport type RequestHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any, cancelled?: boolean, timedOut?: boolean) => void\n  response: (response: TResponse) => void\n  sendResponseMessage: (responseMessage: Message<TRequest, TResponse>) => void\n  createResponseMessage(response: TResponse): Message<TRequest, TResponse>\n}) => void\n\nexport type RequestEventHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n}) => void\n\nexport class InMemoryClientSideServer<TStore> implements MessageBridgeClientServer {\n  store = {} as TStore\n  commands = {} as { [name: string]: RequestHandler }\n  queries = {} as { [name: string]: RequestHandler }\n  eventListeners = {} as { [name: string]: RequestEventHandler }\n\n  saveToLocalStorage(key: string) {\n    localStorage.setItem(key, JSON.stringify(this.store))\n  }\n  loadFromLocalStorage(key: string) {\n    const store = localStorage.getItem(key)\n    if (store) {\n      this.store = JSON.parse(store) as TStore\n    }\n  }\n\n  sendMessage?: (msg: Message<RequestErrorResponse>) => void\n\n  connect(sendMessage: (msg: Message) => void) {\n    this.sendMessage = sendMessage\n  }\n\n  sendError(\n    payload: RequestErrorResponse,\n    trackId?: string,\n    cancelled?: boolean,\n    timedOut?: boolean,\n  ) {\n    const errorMsg = createMessage({\n      trackId,\n      type: MessageType.Error,\n      name: \"Error\",\n      payload: payload,\n      direction: MessageDirection.ToClient,\n      cancelled,\n      timedOut,\n    })\n    //console.log(\"SERVER: sendError\", errorMsg)\n    this.sendMessage?.(errorMsg)\n  }\n\n  createMessage(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = createMessage({\n      ...opt,\n      direction: MessageDirection.ToClient,\n    })\n    return responseMessage\n  }\n\n  sendResponse(opt: { type: MessageType; name: string; payload: any; trackId: string }) {\n    const responseMessage = this.createMessage(opt)\n    //console.log(\"SERVER: sendResponse\", responseMessage)\n    this.sendMessage?.(responseMessage)\n  }\n\n  sendEvent(name: string, payload: any) {\n    const responseMessage = createMessage({\n      type: MessageType.Event,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    this.sendMessage?.(responseMessage)\n  }\n\n  onMessage(requestMessage: Message | string) {\n    //console.log(\"SERVER: onMessage\", requestMessage)\n    if (typeof requestMessage === \"string\") {\n      try {\n        requestMessage = JSON.parse(requestMessage) as Message\n      } catch (e) {\n        this.sendError({\n          message: `Error parsing message: ${e}`,\n          request: requestMessage,\n          error: e,\n          stack: (e as any)?.stack,\n        })\n        console.error(\"Error parsing message\", e)\n        return\n      }\n    }\n    if (requestMessage.type === \"Command\") {\n      if (!this.commands[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Command ${requestMessage.name} not found (Register it with addCommand)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleCommand(requestMessage)\n    }\n    if (requestMessage.type === \"Query\") {\n      if (!this.queries[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Query ${requestMessage.name} not found (Register it with addQuery)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleQuery(requestMessage)\n    }\n    if (requestMessage.type === \"Event\") {\n      if (!this.eventListeners[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Event ${requestMessage.name} not found (Register it with addEvent)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleEvent(requestMessage)\n    }\n  }\n  serverHandleCommand(requestMessage: Message) {\n    const handler = this.commands[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.CommandResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    try {\n      handler({\n        requestMessage: requestMessage,\n        request: requestMessage.payload,\n        store: this.store,\n        error: sendError,\n        event: fireEvent,\n        response: sendResponse,\n        createResponseMessage,\n        sendResponseMessage,\n      })\n    } catch (e) {\n      sendError({\n        message: `Error in command handler for '${requestMessage.name}'`,\n        requestMessage: requestMessage,\n        error: e,\n        stack: (e as any)?.stack,\n      })\n    }\n  }\n\n  serverHandleQuery(requestMessage: Message) {\n    const handler = this.queries[requestMessage.name]\n    const sendResponseMessage = (responseMessage: Message) => {\n      this.sendMessage?.(responseMessage)\n    }\n    const createResponseMessage = (response: any) => {\n      return this.createMessage({\n        name: requestMessage.name,\n        type: MessageType.QueryResponse,\n        payload: response,\n        trackId: requestMessage.trackId,\n      })\n    }\n    const sendResponse = (response: any) => {\n      const message = createResponseMessage(response)\n      sendResponseMessage(message)\n    }\n    const sendError = (reason: any, cancelled?: boolean, timedOut?: boolean) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n        cancelled,\n        timedOut,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n      response: sendResponse,\n      createResponseMessage,\n      sendResponseMessage,\n    })\n  }\n  serverHandleEvent(requestMessage: Message) {\n    const handler = this.eventListeners[requestMessage.name]\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n    })\n  }\n  // In memory message bridge service\n  addCommand<TCommand = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TCommand, TResponse, TStore>,\n  ) {\n    this.commands[name] = handler\n  }\n  addQuery<TQuery = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TQuery, TResponse, TStore>,\n  ) {\n    this.queries[name] = handler\n  }\n  addEventListener<TEvent = any>(\n    name: string,\n    handler: RequestEventHandler<TEvent, void, TStore>,\n  ) {\n    this.eventListeners[name] = handler\n  }\n}\n","import { HubConnectionBuilder } from \"@microsoft/signalr\"\nimport { IHttpConnectionOptions } from \"@microsoft/signalr/src/IHttpConnectionOptions\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class SignalRMessageBridgeService extends MessageBridgeServiceBase {\n  connection?: signalR.HubConnection\n  connect(options: IHttpConnectionOptions = {}): Promise<void> {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.wsUri, options)\n      .withAutomaticReconnect()\n      .build()\n    if (!this.connection) {\n      throw new Error(\"Failed to create SignalR connection\")\n    }\n    this.connection.on(\"ReceiveMessage\", (messageString: string | Message) => {\n      this.onMessage(messageString)\n    })\n    this.connection.onclose((error) => {\n      this.onClose(error)\n    })\n    return this.connection\n      .start()\n      .then(() => {\n        this.onConnect()\n      })\n      .catch((err: Error) => {\n        this.onError(err)\n      })\n  }\n\n  close() {\n    this.connection?.stop()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.connection?.invoke(\"SendMessage\", msgJson).catch((err) => {\n      this.onError(err as Error)\n      return console.error(err.toString())\n    })\n  }\n}\n","import { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class WebsocketMessageBridgeService extends MessageBridgeServiceBase {\n  socket?: WebSocket\n  connectedCallback?: () => void\n\n  connect() {\n    this.socket = new WebSocket(this.wsUri)\n    this.socket.addEventListener(\"message\", (event) => {\n      const messageString: string | Message = event.data\n      this.onMessage(messageString)\n    })\n    this.socket.addEventListener(\"close\", (event) => {\n      this.onClose(event.reason, event)\n    })\n    this.socket.addEventListener(\"error\", (event) => {\n      this.onError(event, event)\n    })\n\n    return new Promise<void>((resolve, reject) => {\n      // Connection opened\n      this.socket?.addEventListener(\"open\", (event) => {\n        this.onConnect()\n        resolve()\n      })\n    })\n  }\n  close(): void {\n    this.socket?.close()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.socket?.send(msgJson)\n  }\n}\n"],"names":["MessageType","MessageDirection","createMessageFromDto","msg","direction","ToClient","isError","type","Error","createMessage","opt","name","payload","trackId","v4","module","schema","created","Date","toISOString","createCommandMessage","Command","Query","createEventMessage","Event","MessageBridgeServiceBase","constructor","wsUri","connected","this","trackedRequestMap","subscribedEventListMap","history","bridgeErrors","options","timeout","undefined","allowResponseValueWhenCancelled","keepHistoryForReceivedMessages","keepHistoryForSendingMessages","logger","console","log","logParseIncomingMessageError","timeoutFromBridgeOptionsMessage","ms","timeoutFromRequestOptionsMessage","logParseIncomingMessageErrorFormat","err","logMessageReceived","logMessageReceivedFormat","logSendingMessage","logSendingMessageFormat","setOptions","getTrackedRequestMessage","requestMessage","cancelRequest","cancelled","onConnect","onError","eventOrData","push","onClose","setOptionalRequestTimeout","onTimeout","reason","timeoutMs","setTimeout","timedOut","responseMessage","request","sendMessageTracked","cancel","requestOptions","sendCancelled","sendCancelledRequest","Promise","resolve","reject","sendMessagePromiseHandler","handleSuccess","response","handleError","throwOnTrackedError","finally","sendMessage","cancelPromiseValue","error","avoidThrowOnNonTrackedError","ToServer","interceptSendMessage","handleErrorMessage","errOpt","optionalTimeId","clearTimeout","resolveWithError","errorMessage","callOnErrorWhenRequestIsCancelled","timeoutErrorMessage","handleCancelOptions","successTrack","handleCancelResponse","callOnSuccessWhenRequestIsCancelled","onSuccess","errorTrack","internalSendMessage","resolveCancel","resolveCancelledForNonTracked","resolveCancelledNonTrackedRequest","subscribeEvent","onEvent","Array","isArray","map","_name","unsubs","forEach","unsub","index","findIndex","x","splice","createTrackedMessage","sendOptions","createdMessage","send","sendTracked","interceptCreatedMessageOptions","createCommand","createQuery","createQueryMessage","sendCommand","sendCommandTracked","sendQuery","sendQueryTracked","createEvent","eventOptions","eventMessage","createdEvent","interceptCreatedEventMessageOptions","sendEvent","onMessage","messageString","messageDto","JSON","parse","e","interceptReceivedMessage","handleIncomingMessage","logData","logSendingMessageFilter","match","onSend","sendNetworkMessage","logMessageReceivedFilter","errorHandled","receiveEventMessage","trackMsg","eventMsg","callback","ClientSideMessageBridgeService","server","setServer","connect","msgDetachRef","stringify","close","store","commands","queries","eventListeners","saveToLocalStorage","key","localStorage","setItem","loadFromLocalStorage","getItem","sendError","errorMsg","sendResponse","message","stack","serverHandleCommand","serverHandleQuery","serverHandleEvent","handler","sendResponseMessage","createResponseMessage","CommandResponse","fireEvent","event","QueryResponse","addCommand","addQuery","addEventListener","connection","withUrl","withAutomaticReconnect","build","on","onclose","start","then","catch","stop","msgJson","invoke","toString","WebsocketMessageBridgeService","socket","connectedCallback","WebSocket","data"],"mappings":"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"}