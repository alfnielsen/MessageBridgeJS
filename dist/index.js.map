{"version":3,"file":"index.js","sources":["../src/MessageBridgeTypes.ts","../src/MessageBridgeHelper.ts","../src/MessageBridgeServiceBase.ts","../src/services/ClientSideMessageBridgeService.ts","../src/services/InMemoryClientSideServer.ts","../src/services/SignalRMessageBridgeService.ts","../src/services/WebsocketMessageBridgeService.ts"],"sourcesContent":["// Typescript util\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type OmitAndOptional<\n  T,\n  TOmit extends keyof T,\n  TOpt extends keyof Omit<T, TOmit>,\n> = Pick<Partial<Omit<T, TOmit>>, TOpt> & Omit<Omit<T, TOmit>, TOpt>\n\n// bridge\nexport type BridgeOptions = {\n  // Add listeners:\n  onMessage?: (msg: Message) => void\n  onSend?: (msg: Message) => void\n  onError?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onClose?: (err?: unknown /*Error*/, eventOrData?: unknown) => void\n  onConnect?: () => void\n  // Interception:\n  // - can be used to generalize behavior (Happens as early as possible in the process)\n  // Happens just after user options is applied. Before stored in track map and before any other actions.\n  interceptSendMessage?: (msg: Message) => Message // (default: undefined)\n  // Happens after message-string parsing, but before stored in history, onMessage and all other actions\n  // To get request for the message use: getTrackedRequestMessage(trackId: string): Message | undefined\n  interceptReceivedMessage?: (msg: Message) => Message // (default: undefined)\n  // Handle errors and timeouts:\n  avoidThrowOnNonTrackedError?: boolean // (default: undefined)\n  throwOnTrackedError?: boolean // (default: undefined)\n  timeout?: number // (default: undefined)\n  // Debugging options:\n  timeoutFromBridgeOptionsMessage?: (ms: number) => string // (has default implementation)\n  timeoutFromRequestOptionsMessage?: (ms: number) => string // (has default implementation)\n  keepHistoryForReceivedMessages?: boolean // (default: false)\n  keepHistoryForSendingMessages?: boolean // (default: false)\n  logger?: (...data: any[]) => void // set custom logger (default: console?.log)\n  logParseIncomingMessageError?: boolean // (default: true)\n  logParseIncomingMessageErrorFormat?: (err: unknown) => any[] // (has default implementation)\n  logMessageReceived?: boolean // log all messages received\n  logMessageReceivedFormat?: (msg: Message) => any[] // (has default implementation)\n  logSendingMessage?: boolean // log all messages sent\n  logSendingMessageFormat?: (msg: Message) => any[] // (has default implementation)\n  logMessageReceivedFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n  logSendingMessageFilter?: undefined | string | RegExp // restrict logging to messages matching this filter\n}\n// enums (These are runtime enums)\nexport enum MessageType {\n  Command = \"Command\",\n  CommandResponse = \"CommandResponse\",\n  Query = \"Query\",\n  QueryResponse = \"QueryResponse\",\n  Event = \"Event\",\n  Error = \"Error\",\n}\n\nexport enum MessageDirection {\n  ToClient = \"ToClient\",\n  ToServer = \"ToServer\",\n}\n\n// types (Not runtime)\nexport type Message<TPayload = any, TSchema = any> = {\n  module?: string\n  name: string\n  type: MessageType\n  isError: boolean\n  trackId: string\n  created: string\n  payload: TPayload\n  schema?: TSchema\n  direction: MessageDirection\n}\n\n// Request\nexport type RequestResponse<TRequest, TResponse, TError = any> = {\n  response: TResponse\n  request: TRequest\n  responseMessage: Message<TResponse>\n  requestMessage: Message<TRequest>\n  isError?: boolean\n  error?: TError\n  errorMessage?: Message<TError>\n}\n\nexport type RequestOptionsTracked<TRequest, TResponse, TError = any> = {\n  name: string\n  payload: TRequest\n  onSuccess?: SubscribeResponseTracked<TRequest, TResponse>\n  onError?: SubscribeErrorResponseTracked<TRequest, TResponse, TError>\n  module?: string\n  timeout?: number\n}\n\nexport type SendMessageOptions<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n  TSchema = any,\n> = {\n  requestMessage: Message<TRequest, TSchema>\n  onSuccess?: SubscribeResponseTracked<TRequest, TResponse>\n  onError?: SubscribeErrorResponseTracked<TRequest, TResponse, TError>\n  timeout?: number\n}\n\nexport type SubscribeResponseAsync<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => Promise<RequestResponse<TRequest, TResponse>>\n\nexport type SubscribeResponseTracked<TRequest, TResponse> = (\n  opt: RequestResponse<TRequest, TResponse>,\n) => void\n\nexport type SubscribeResponseWithCallbacks<TRequest, TResponse, TError = any> = {\n  onSuccess?: SubscribeResponseAsync<TRequest, TResponse>\n  onError?: SubscribeErrorAsync<TError, TRequest>\n  requestMessage: Message<TRequest>\n}\n\nexport type SubscribeEvent<TResponse> = (\n  payload: TResponse,\n  eventMessage: Message<TResponse>,\n) => void\n\n// Error\nexport type RequestError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type RequestMaybeNoError<TError = any, TRequest = any> = {\n  reason?: TError\n  request: TRequest\n  responseMessage?: Message<TError>\n  requestMessage: Message<TRequest>\n}\n\nexport type SubscribeErrorAsync<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => Promise<RequestResponse<TError, TRequest>>\n\nexport type SubscribeError<TError = any, TRequest = any> = (\n  opt: RequestMaybeNoError<TError, TRequest>,\n) => void\n\nexport type SubscribeErrorResponseTracked<\n  TRequest = any,\n  TResponse = any,\n  TError = any,\n> = (opt: RequestResponse<TRequest, TResponse, TError>) => void\n\n// Internal Tracked\n// used by tracking (No return value '=> void', it uses promise 'resolve')\nexport type InternalTrackedSubscribeResponse<TResponse> = (\n  responseMessage: Message<TResponse>,\n) => void\n\nexport type InternalTrackedSubscribeError<TError> = (\n  responseMessage: Message<TError> | undefined,\n) => void\n\nexport type InternalTrackedSubscribeResponseWithCatch<\n  TRequest,\n  TResponse,\n  TError = any,\n> = {\n  successTrack?: InternalTrackedSubscribeResponse<TResponse>\n  errorTrack?: InternalTrackedSubscribeError<TError>\n  requestMessage: Message<TRequest>\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  OmitAndOptional,\n} from \"./MessageBridgeTypes\"\nimport { v4 } from \"uuid\"\n\nexport function createMessageFromDto<TPayload = any, TSchema = any>(\n  msg: Message<TPayload, TSchema>,\n  direction = MessageDirection.ToClient,\n): Message<TPayload, TSchema> {\n  msg.isError = msg.type === MessageType.Error\n  msg.direction ??= direction\n  return msg\n}\n\nexport function createMessage<TPayload = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TPayload, TSchema>,\n    \"created\" | \"isError\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TPayload, TSchema> {\n  return {\n    name: opt.name,\n    payload: opt.payload,\n    type: opt.type,\n    // optionals\n    direction: opt.direction ?? MessageDirection.ToClient,\n    trackId: opt.trackId ?? v4(),\n    module: opt.module,\n    schema: opt.schema,\n    // alway created\n    created: new Date().toISOString(),\n    isError: opt.type === MessageType.Error,\n  }\n}\n\nexport function createCommandMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n): Message<TRequest, TSchema> {\n  return createMessage({\n    ...opt,\n    type: MessageType.Command,\n  })\n}\n\nexport function createQueryMessage<TRequest = any, TSchema = any>(\n  opt: OmitAndOptional<\n    Message<TRequest, TSchema>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Query,\n  })\n}\n\nexport function createEventMessage<TRequest = any>(\n  opt: OmitAndOptional<\n    Message<TRequest>,\n    \"created\" | \"isError\" | \"type\",\n    \"trackId\" | \"direction\" | \"payload\"\n  >,\n) {\n  return createMessage({\n    ...opt,\n    type: MessageType.Event,\n    payload: undefined,\n  })\n}\n","import {\n  Message,\n  MessageDirection,\n  MessageType,\n  RequestResponse,\n  SubscribeEvent,\n  InternalTrackedSubscribeResponseWithCatch,\n  OmitAndOptional,\n  SubscribeError,\n  RequestOptionsTracked,\n  BridgeOptions,\n  RequestMaybeNoError,\n  SendMessageOptions,\n} from \"./MessageBridgeTypes\"\n\nimport {\n  createCommandMessage,\n  createEventMessage,\n  createMessageFromDto,\n  createQueryMessage,\n} from \"./MessageBridgeHelper\"\n\nexport abstract class MessageBridgeServiceBase {\n  connected = false\n  subscribedTrackIdMap: {\n    [trackId: string]: InternalTrackedSubscribeResponseWithCatch<any, any>\n  } = {}\n\n  subscribedEventListMap: {\n    [eventName: string]: SubscribeEvent<any>[]\n  } = {}\n\n  history: Message[] = []\n  bridgeErrors: unknown[] /*Error*/ = []\n\n  options: BridgeOptions = {\n    timeout: undefined,\n    keepHistoryForReceivedMessages: false,\n    keepHistoryForSendingMessages: false,\n    logger: (...data: any[]) => console?.log ?? (() => {}),\n    logParseIncomingMessageError: true,\n    timeoutFromBridgeOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (BridgeOptions.timeout)`,\n    timeoutFromRequestOptionsMessage: (ms: number) =>\n      `Timeout after ${ms}ms (RequestOptions.timeout)`,\n    logParseIncomingMessageErrorFormat: (err: unknown) => [\n      \"Bridge-Error (parse messageReceived):\",\n      err,\n    ],\n    logMessageReceived: false,\n    logMessageReceivedFormat: (msg: Message) => [\"Bridge (messageReceived):\", msg],\n    logSendingMessage: false,\n    logSendingMessageFormat: (msg: Message) => [\"Bridge (sendingMessage):\", msg],\n  }\n\n  constructor(public wsUri: string) {}\n\n  abstract connect(options?: unknown): Promise<void>\n  abstract close(): void\n  abstract sendNetworkMessage(msg: Message): void\n\n  setOptions(opt: BridgeOptions) {\n    this.options = { ...this.options, ...opt }\n  }\n\n  getTrackedRequestMessage(trackId: string): Message | undefined {\n    return this.subscribedTrackIdMap[trackId]?.requestMessage\n  }\n\n  // the following methods can overwritten with class inheritance\n  // but should override version should call super.methodName()\n  protected onConnect() {\n    this.connected = true\n    this.options.onConnect?.()\n  }\n  protected onError(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.options.onError?.(err, eventOrData)\n  }\n  protected onClose(err?: unknown /*Error*/, eventOrData?: unknown) {\n    if (err !== undefined) {\n      this.bridgeErrors.push(err)\n    }\n    this.connected = false\n    this.options.onClose?.(err, eventOrData)\n  }\n\n  // base methods (should mostly not be overwritten)\n\n  protected setOptionalRequestTimeout<TRequest = any, TSchema = any>({\n    requestMessage,\n    timeout,\n    onTimeout,\n  }: {\n    requestMessage: Message<TRequest, TSchema>\n    timeout: number | undefined\n    onTimeout: SubscribeError<string, TRequest>\n  }) {\n    let reason: string\n    let timeoutMs: number | undefined\n\n    if (this.options.timeout !== undefined) {\n      reason =\n        this.options.timeoutFromBridgeOptionsMessage?.(this.options.timeout) ??\n        `timeout after ${this.options.timeout}`\n      timeoutMs = this.options.timeout\n    }\n    if (timeout !== undefined) {\n      reason =\n        this.options.timeoutFromRequestOptionsMessage?.(timeout) ??\n        `timeout after ${timeout}`\n      timeoutMs = timeout\n    }\n    if (timeoutMs === undefined) {\n      return\n    }\n    return setTimeout(() => {\n      const opt: RequestMaybeNoError<string, TRequest> = {\n        reason,\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n      }\n      onTimeout(opt)\n    }, timeoutMs)\n  }\n\n  sendMessageTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    return new Promise<RequestResponse<TRequest, TResponse, TError>>(\n      (resolve, reject) => {\n        this.sendMessagePromiseHandler({\n          ...opt,\n          handleResponseReject: (isError, response) => {\n            if (isError) {\n              if (this.options.throwOnTrackedError) {\n                reject(response)\n              } else {\n                resolve(response)\n              }\n            } else {\n              resolve(response)\n            }\n          },\n        })\n      },\n    ).finally(() => {\n      delete this.subscribedTrackIdMap[opt.requestMessage.trackId]\n    })\n  }\n\n  /**\n   * Only resolve the promise with the TResponse (not the tracked/full response)\n   * onSuccess contains the response in the first argument (and the the tracked/full response in the second argument)\n   */\n  sendMessage<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: SendMessageOptions<TRequest, TResponse, TError, TSchema>,\n  ) {\n    return new Promise<TResponse>((resolve, reject) => {\n      this.sendMessagePromiseHandler({\n        ...opt,\n        handleResponseReject: (isError, response, error) => {\n          if (isError) {\n            if (this.options.avoidThrowOnNonTrackedError) {\n              //@ts-ignore (The response is not the correct type, but we ignore it)\n              resolve(error?.payload)\n            } else {\n              reject(response)\n            }\n          } else {\n            resolve(response.response)\n          }\n        },\n      })\n    })\n  }\n\n  protected sendMessagePromiseHandler<\n    TRequest = any,\n    TResponse = any,\n    TError = any,\n    TSchema = any,\n  >({\n    handleResponseReject,\n    requestMessage,\n    onSuccess,\n    onError,\n    timeout,\n  }: SendMessageOptions<TRequest, TResponse, TError, TSchema> & {\n    handleResponseReject: (\n      isError: boolean,\n      response: RequestResponse<TRequest, TResponse, TError>,\n      error?: RequestMaybeNoError<any, TRequest>,\n    ) => void\n  }) {\n    requestMessage.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      requestMessage = this.options.interceptSendMessage(requestMessage)\n    }\n\n    // handle error and timeout\n    const handleError = (errOpt: RequestMaybeNoError<any, TRequest>) => {\n      if (optionalTimeId) {\n        clearTimeout(optionalTimeId)\n      }\n      // resolve with error\n      const resolveWithError: RequestResponse<TRequest, TResponse, TError> = {\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        response: undefined,\n        //@ts-ignore (The response is not the correct type, but we ignore it)\n        responseMessage: undefined,\n        request: requestMessage.payload,\n        requestMessage,\n        isError: true,\n        error: errOpt.reason,\n        errorMessage: errOpt.responseMessage,\n      }\n      this.onError(resolveWithError)\n      onError?.(resolveWithError)\n      handleResponseReject(true, resolveWithError, errOpt)\n    }\n    // set timeout if needed\n    const optionalTimeId = this.setOptionalRequestTimeout({\n      requestMessage,\n      timeout,\n      onTimeout: (timeoutErrorMessage) => {\n        handleError(timeoutErrorMessage)\n      },\n    })\n    // add to subscribedTrackIdMap\n    this.subscribedTrackIdMap[requestMessage.trackId] = {\n      successTrack: (responseMessage) => {\n        const opt: RequestResponse<TRequest, TResponse, TError> = {\n          response: responseMessage.payload,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n          isError: false,\n        }\n        if (optionalTimeId) {\n          clearTimeout(optionalTimeId)\n        }\n        onSuccess?.(opt)\n        handleResponseReject(false, opt, undefined)\n      },\n      errorTrack: (responseMessage) => {\n        const opt: RequestMaybeNoError<TError, TRequest> = {\n          reason: responseMessage?.payload,\n          responseMessage,\n          request: requestMessage.payload,\n          requestMessage,\n        }\n        handleError(opt)\n      },\n      requestMessage: requestMessage,\n    } as InternalTrackedSubscribeResponseWithCatch<TRequest, TResponse, TError>\n    // send message\n    this.internalSendMessage(requestMessage)\n  }\n\n  subscribeEvent<TResponse = any>({\n    name,\n    onEvent,\n  }: {\n    name: string | string[]\n    onEvent: SubscribeEvent<TResponse>\n  }): () => void {\n    if (Array.isArray(name)) {\n      const unsubs = name.map((_name) => this.subscribeEvent({ name: _name, onEvent }))\n      return () => unsubs.forEach((unsub) => unsub())\n    }\n    if (!this.subscribedEventListMap[name]) this.subscribedEventListMap[name] = []\n    this.subscribedEventListMap[name].push(onEvent)\n    return () => {\n      const index = this.subscribedEventListMap[name].findIndex((x) => x === onEvent)\n      this.subscribedEventListMap[name].splice(index, 1)\n    }\n  }\n\n  sendCommand<TRequest = any, TResponse = any, TSchema = any>(\n    opt: RequestOptionsTracked<TRequest, TResponse>,\n  ) {\n    const msg = createCommandMessage(opt)\n    return this.sendMessage<TRequest, TResponse, TSchema>({\n      requestMessage: msg,\n      onSuccess: opt.onSuccess,\n      onError: opt.onError,\n      timeout: opt.timeout,\n    })\n  }\n\n  sendCommandTracked<TRequest = any, TResponse = any, TSchema = any>(\n    opt: RequestOptionsTracked<TRequest, TResponse>,\n  ) {\n    const msg = createCommandMessage(opt)\n    return this.sendMessageTracked<TRequest, TResponse, TSchema>({\n      requestMessage: msg,\n      onSuccess: opt.onSuccess,\n      onError: opt.onError,\n      timeout: opt.timeout,\n    })\n  }\n\n  sendQuery<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: RequestOptionsTracked<TRequest, TResponse>,\n  ) {\n    const msg = createQueryMessage(opt)\n    return this.sendMessage<TRequest, TResponse, TError, TSchema>({\n      requestMessage: msg,\n      onSuccess: opt.onSuccess,\n      onError: opt.onError,\n      timeout: opt.timeout,\n    })\n  }\n\n  sendQueryTracked<TRequest = any, TResponse = any, TError = any, TSchema = any>(\n    opt: RequestOptionsTracked<TRequest, TResponse, TError>,\n  ) {\n    const msg = createQueryMessage(opt)\n    return this.sendMessageTracked<TRequest, TResponse, TError, TSchema>({\n      requestMessage: msg,\n      onSuccess: opt.onSuccess,\n      onError: opt.onError,\n      timeout: opt.timeout,\n    })\n  }\n\n  sendEvent<TPayload = any>(\n    top: OmitAndOptional<\n      Message<TPayload>,\n      \"trackId\" | \"created\" | \"isError\" | \"type\",\n      \"direction\"\n    >,\n  ) {\n    let msg = createEventMessage(top)\n    msg.direction = MessageDirection.ToServer\n    if (this.options.interceptSendMessage) {\n      msg = this.options.interceptSendMessage(msg)\n    }\n    this.internalSendMessage(msg)\n    return msg\n  }\n\n  protected onMessage(messageString: string | Message) {\n    //console.log(\"onMessage\", messageString)\n    let messageDto: Message\n    try {\n      messageDto =\n        typeof messageString === \"string\"\n          ? (JSON.parse(messageString) as Message)\n          : messageString\n    } catch (e) {\n      this.onError(e as Error)\n      //console.log(\"Incorrect message received: \" + messageString)\n      return\n    }\n    try {\n      let msg = createMessageFromDto(messageDto)\n      if (this.options.interceptReceivedMessage) {\n        msg = this.options.interceptReceivedMessage(msg)\n      }\n      this.handleIncomingMessage(msg)\n    } catch (e) {\n      this.onError(e as Error)\n      if (this.options?.logger && this.options?.logParseIncomingMessageError) {\n        const logData = this.options?.logParseIncomingMessageErrorFormat?.(\n          messageDto,\n        ) ?? [e]\n        this.options.logger(logData)\n      }\n    }\n  }\n\n  protected internalSendMessage(msg: Message) {\n    if (this.options.keepHistoryForSendingMessages) {\n      this.history.push(msg)\n    }\n    if (this.options?.logger && this.options?.logSendingMessage) {\n      let log = true\n      if (this.options?.logSendingMessageFilter) {\n        log = !!msg.name.match(this.options?.logSendingMessageFilter)\n      }\n      if (log) {\n        const logData = this.options?.logSendingMessageFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onSend?.(msg)\n    this.sendNetworkMessage(msg)\n  }\n\n  protected handleIncomingMessage(msg: Message) {\n    //console.log(\"handleIncomingMessage\", msg)\n    if (this.options.keepHistoryForReceivedMessages) {\n      this.history.push(msg)\n    }\n    if (this.options?.logger && this.options?.logMessageReceived) {\n      let log = true\n      if (this.options?.logMessageReceivedFilter) {\n        log = !!msg.name.match(this.options?.logMessageReceivedFilter)\n      }\n      if (log) {\n        const logData = this.options?.logMessageReceivedFormat?.(msg) ?? [msg]\n        this.options.logger(...logData)\n      }\n    }\n    this.options.onMessage?.(msg)\n\n    let errorHandled = msg.type !== MessageType.Error\n\n    if (msg.type === MessageType.Event) {\n      this.receiveEventMessage(msg)\n      return\n    }\n    const trackMsg = this.subscribedTrackIdMap[msg.trackId]\n    if (trackMsg) {\n      if (msg.type === MessageType.Error) {\n        trackMsg.errorTrack?.(msg)\n        errorHandled = true\n      } else {\n        trackMsg.successTrack?.(msg)\n      }\n      delete this.subscribedTrackIdMap[msg.trackId]\n    }\n\n    if (!errorHandled) {\n      this.onError?.(msg)\n    }\n  }\n\n  protected receiveEventMessage(eventMsg: Message) {\n    if (this.subscribedEventListMap[eventMsg.name]) {\n      this.subscribedEventListMap[eventMsg.name].forEach((callback) =>\n        callback(eventMsg.payload, eventMsg),\n      )\n    }\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\n\nexport type MessageBridgeClientServer = {\n  onMessage: (msg: Message) => void\n  connect: (sendMessage: (msg: Message) => void) => void\n}\n\nexport class ClientSideMessageBridgeService extends MessageBridgeServiceBase {\n  server?: MessageBridgeClientServer\n  setServer(server: MessageBridgeClientServer) {\n    this.server = server\n  }\n  connect() {\n    if (!this.server) {\n      throw new Error(\"No server set\")\n    }\n    this.server?.connect((msg) => {\n      this.onMessage(msg)\n      this.onConnect()\n    })\n    return Promise.resolve()\n  }\n  close() {\n    this.onClose()\n  }\n  sendNetworkMessage(msg: Message) {\n    setTimeout(() => {\n      this.server?.onMessage(msg)\n    }, 10)\n  }\n}\n","import { createMessage } from \"../MessageBridgeHelper\"\nimport { Message, MessageDirection, MessageType } from \"../MessageBridgeTypes\"\nimport { MessageBridgeClientServer } from \"./ClientSideMessageBridgeService\"\n\nexport type RequestErrorResponse = {\n  message: string\n  request?: Message | string\n  stack?: string\n  error?: unknown\n}\n\nexport type RequestHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n  response: (response: TResponse) => void\n}) => void\n\nexport type RequestEventHandler<TRequest = any, TResponse = any, TStore = any> = (opt: {\n  requestMessage: Message<TRequest, TResponse>\n  request: TRequest\n  store: TStore\n  event: (name: string, payload: any) => void\n  error: (reason: any) => void\n}) => void\n\nexport class InMemoryClientSideServer<TStore> implements MessageBridgeClientServer {\n  store = {} as TStore\n  commands = {} as { [name: string]: RequestHandler }\n  queries = {} as { [name: string]: RequestHandler }\n  eventListeners = {} as { [name: string]: RequestEventHandler }\n\n  saveToLocalStorage(key: string) {\n    localStorage.setItem(key, JSON.stringify(this.store))\n  }\n  loadFromLocalStorage(key: string) {\n    const store = localStorage.getItem(key)\n    if (store) {\n      this.store = JSON.parse(store) as TStore\n    }\n  }\n\n  sendMessage?: (msg: Message<RequestErrorResponse>) => void\n\n  connect(sendMessage: (msg: Message) => void) {\n    this.sendMessage = sendMessage\n  }\n\n  sendError(payload: RequestErrorResponse, trackId?: string) {\n    const errorMsg = createMessage({\n      trackId,\n      type: MessageType.Error,\n      name: \"Error\",\n      payload: payload,\n      direction: MessageDirection.ToClient,\n    })\n    //console.log(\"SERVER: sendError\", errorMsg)\n    this.sendMessage?.(errorMsg)\n  }\n\n  sendResponse(type: MessageType, name: string, payload: any, trackId: string) {\n    const responseMessage = createMessage({\n      trackId,\n      type,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    //console.log(\"SERVER: sendResponse\", responseMessage)\n    this.sendMessage?.(responseMessage)\n  }\n\n  sendEvent(name: string, payload: any) {\n    const responseMessage = createMessage({\n      type: MessageType.Event,\n      name,\n      payload,\n      direction: MessageDirection.ToClient,\n    })\n    this.sendMessage?.(responseMessage)\n  }\n\n  onMessage(requestMessage: Message | string) {\n    //console.log(\"SERVER: onMessage\", requestMessage)\n    if (typeof requestMessage === \"string\") {\n      try {\n        requestMessage = JSON.parse(requestMessage) as Message\n      } catch (e) {\n        this.sendError({\n          message: `Error parsing message: ${e}`,\n          request: requestMessage,\n          error: e,\n          stack: (e as any)?.stack,\n        })\n        console.error(\"Error parsing message\", e)\n        return\n      }\n    }\n    if (requestMessage.type === \"Command\") {\n      if (!this.commands[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Command ${requestMessage.name} not found (Register it with addCommand)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleCommand(requestMessage)\n    }\n    if (requestMessage.type === \"Query\") {\n      if (!this.queries[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Query ${requestMessage.name} not found (Register it with addQuery)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleQuery(requestMessage)\n    }\n    if (requestMessage.type === \"Event\") {\n      if (!this.eventListeners[requestMessage.name]) {\n        this.sendError(\n          {\n            message: `Event ${requestMessage.name} not found (Register it with addEvent)`,\n            request: requestMessage,\n          },\n          requestMessage.trackId,\n        )\n        return\n      }\n      this.serverHandleEvent(requestMessage)\n    }\n  }\n  serverHandleCommand(requestMessage: Message) {\n    const handler = this.commands[requestMessage.name]\n    const sendResponse = (response: any) => {\n      this.sendResponse(\n        MessageType.CommandResponse,\n        requestMessage.name,\n        response,\n        requestMessage.trackId,\n      )\n    }\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    try {\n      handler({\n        requestMessage: requestMessage,\n        request: requestMessage.payload,\n        store: this.store,\n        error: sendError,\n        event: fireEvent,\n        response: sendResponse,\n      })\n    } catch (e) {\n      sendError({\n        message: `Error in command handler for '${requestMessage.name}'`,\n        requestMessage: requestMessage,\n        error: e,\n        stack: (e as any)?.stack,\n      })\n    }\n  }\n\n  serverHandleQuery(requestMessage: Message) {\n    const handler = this.queries[requestMessage.name]\n    const sendResponse = (response: any) => {\n      this.sendResponse(\n        MessageType.QueryResponse,\n        requestMessage.name,\n        response,\n        requestMessage.trackId,\n      )\n    }\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n      response: sendResponse,\n    })\n  }\n  serverHandleEvent(requestMessage: Message) {\n    const handler = this.eventListeners[requestMessage.name]\n    const sendError = (reason: any) => {\n      this.sendError(\n        {\n          message: reason,\n          request: requestMessage,\n        },\n        requestMessage.trackId,\n      )\n    }\n    const fireEvent = (name: string, payload: any) => {\n      this.sendEvent(name, payload)\n    }\n    handler({\n      requestMessage: requestMessage,\n      request: requestMessage.payload,\n      store: this.store,\n      error: sendError,\n      event: fireEvent,\n    })\n  }\n  // In memory message bridge service\n  addCommand<TCommand = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TCommand, TResponse, TStore>,\n  ) {\n    this.commands[name] = handler\n  }\n  addQuery<TQuery = any, TResponse = any>(\n    name: string,\n    handler: RequestHandler<TQuery, TResponse, TStore>,\n  ) {\n    this.queries[name] = handler\n  }\n  addEventListener<TEvent = any>(\n    name: string,\n    handler: RequestEventHandler<TEvent, void, TStore>,\n  ) {\n    this.eventListeners[name] = handler\n  }\n}\n","import { HubConnectionBuilder } from \"@microsoft/signalr\"\nimport { IHttpConnectionOptions } from \"@microsoft/signalr/src/IHttpConnectionOptions\"\nimport { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class SignalRMessageBridgeService extends MessageBridgeServiceBase {\n  connection?: signalR.HubConnection\n  connect(options: IHttpConnectionOptions = {}): Promise<void> {\n    this.connection = new HubConnectionBuilder()\n      .withUrl(this.wsUri, options)\n      .withAutomaticReconnect()\n      .build()\n    if (!this.connection) {\n      throw new Error(\"Failed to create SignalR connection\")\n    }\n    this.connection.on(\"ReceiveMessage\", (messageString: string | Message) => {\n      this.onMessage(messageString)\n    })\n    this.connection.onclose((error) => {\n      this.onClose(error)\n    })\n    return this.connection\n      .start()\n      .then(() => {\n        this.onConnect()\n      })\n      .catch((err: Error) => {\n        this.onError(err)\n      })\n  }\n\n  close() {\n    this.connection?.stop()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.connection?.invoke(\"SendMessage\", msgJson).catch((err) => {\n      this.onError(err as Error)\n      return console.error(err.toString())\n    })\n  }\n}\n","import { MessageBridgeServiceBase } from \"../MessageBridgeServiceBase\"\nimport { Message } from \"../MessageBridgeTypes\"\n\nexport class WebsocketMessageBridgeService extends MessageBridgeServiceBase {\n  socket?: WebSocket\n  connectedCallback?: () => void\n\n  connect() {\n    this.socket = new WebSocket(this.wsUri)\n    this.socket.addEventListener(\"message\", (event) => {\n      const messageString: string | Message = event.data\n      this.onMessage(messageString)\n    })\n    this.socket.addEventListener(\"close\", (event) => {\n      this.onClose(event.reason, event)\n    })\n    this.socket.addEventListener(\"error\", (event) => {\n      this.onError(event, event)\n    })\n\n    return new Promise<void>((resolve, reject) => {\n      // Connection opened\n      this.socket?.addEventListener(\"open\", (event) => {\n        this.onConnect()\n        resolve()\n      })\n    })\n  }\n  close(): void {\n    this.socket?.close()\n    this.onClose()\n  }\n\n  sendNetworkMessage(msg: Message) {\n    const msgJson = JSON.stringify(msg)\n    this.socket?.send(msgJson)\n  }\n}\n"],"names":["MessageType","MessageDirection","msg","direction","ToClient","isError","type","Error","createMessage","opt","name","payload","trackId","v4","module","schema","created","Date","toISOString","createCommandMessage","Command","Query","createEventMessage","Event","undefined","MessageBridgeServiceBase","constructor","wsUri","connected","subscribedTrackIdMap","this","subscribedEventListMap","history","bridgeErrors","options","timeout","keepHistoryForReceivedMessages","keepHistoryForSendingMessages","logger","console","log","logParseIncomingMessageError","timeoutFromBridgeOptionsMessage","ms","timeoutFromRequestOptionsMessage","logParseIncomingMessageErrorFormat","err","logMessageReceived","logMessageReceivedFormat","logSendingMessage","logSendingMessageFormat","setOptions","getTrackedRequestMessage","requestMessage","onConnect","onError","eventOrData","push","onClose","setOptionalRequestTimeout","onTimeout","reason","timeoutMs","setTimeout","responseMessage","request","sendMessageTracked","Promise","resolve","reject","sendMessagePromiseHandler","handleResponseReject","response","throwOnTrackedError","finally","sendMessage","error","avoidThrowOnNonTrackedError","onSuccess","ToServer","interceptSendMessage","handleError","errOpt","optionalTimeId","clearTimeout","resolveWithError","errorMessage","timeoutErrorMessage","successTrack","errorTrack","internalSendMessage","subscribeEvent","onEvent","Array","isArray","unsubs","map","_name","forEach","unsub","findIndex","x","splice","index","sendCommand","sendCommandTracked","sendQuery","createQueryMessage","sendQueryTracked","sendEvent","top","onMessage","messageString","messageDto","JSON","parse","e","createMessageFromDto","interceptReceivedMessage","handleIncomingMessage","logData","logSendingMessageFilter","match","onSend","sendNetworkMessage","logMessageReceivedFilter","errorHandled","receiveEventMessage","trackMsg","eventMsg","callback","server","setServer","connect","close","store","commands","queries","eventListeners","saveToLocalStorage","key","localStorage","setItem","stringify","loadFromLocalStorage","getItem","sendError","errorMsg","sendResponse","message","stack","serverHandleCommand","serverHandleQuery","serverHandleEvent","handler","CommandResponse","fireEvent","event","QueryResponse","addCommand","addQuery","addEventListener","connection","withUrl","withAutomaticReconnect","build","on","onclose","start","then","catch","stop","msgJson","invoke","toString","WebsocketMessageBridgeService","socket","connectedCallback","WebSocket","data","send"],"mappings":"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"}